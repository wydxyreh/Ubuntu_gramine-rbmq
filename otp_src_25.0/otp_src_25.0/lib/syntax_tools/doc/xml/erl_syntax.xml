<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE erlref SYSTEM "erlref.dtd">
<erlref>
<header>
<title>erl_syntax</title>
<prepared></prepared>
<responsible></responsible>
<docno>1</docno>
<approved></approved>
<checked></checked>
<date></date>
<rev>A</rev>
<file>erl_syntax.xml</file></header>
<module>erl_syntax</module>
<modulesummary>Abstract Erlang syntax trees.</modulesummary>
<description>
<p>Abstract Erlang syntax trees.</p>
 
  <p>This module defines an abstract data type for representing Erlang
  source code as syntax trees, in a way that is backwards compatible
  with the data structures created by the Erlang standard library
  parser module <c>erl_parse</c> (often referred to as "parse
  trees", which is a bit of a misnomer). This means that all
  <c>erl_parse</c> trees are valid abstract syntax trees, but the
  reverse is not true: abstract syntax trees can in general not be used
  as input to functions expecting an <c>erl_parse</c> tree.
  However, as long as an abstract syntax tree represents a correct
  Erlang program, the function <seemfa marker="#revert/1">revert/1</seemfa> should be able to
  transform it to the corresponding <c>erl_parse</c>  
representation.</p>
 
  <p>A recommended starting point for the first-time user is the documentation
  of the <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl> data type, and the function <seemfa marker="#type/1">type/1</seemfa>.</p>
 
  <p><marker id="NOTES:"/><em>NOTES:</em></p>
 
  <p>This module deals with the composition and decomposition of
  <em>syntactic</em> entities (as opposed to semantic ones); its  
purpose is to hide all direct references to the data structures used  
to represent these entities. With few exceptions, the functions in  
this module perform no semantic interpretation of their inputs, and  
in general, the user is assumed to pass type-correct arguments - if  
this is not done, the effects are not defined.</p>
 
  <p>With the exception of the <seeerl marker="#type-erl_parse">erl_parse()</seeerl> data structures,
  the internal representations of abstract syntax trees are subject to
  change without notice, and should not be documented outside this
  module. Furthermore, we do not give any guarantees on how an abstract
  syntax tree may or may not be represented, <em>with the following
  exceptions</em>: no syntax tree is represented by a single atom, such
  as <c>none</c>, by a list constructor <c>[X | Y]</c>, or
  by the empty list <c>[]</c>. This can be relied on when writing
  functions that operate on syntax trees.</p></description>
<section><title>DATA TYPES</title><marker id="types"/>

<taglist>
<tag><marker id="type-annotation_or_location"/>annotation_or_location() = <seeerl marker="stdlib:erl_anno#type-anno">erl_anno:anno()</seeerl> | <seeerl marker="stdlib:erl_anno#type-location">erl_anno:location()</seeerl></tag>
<item><p/> </item>
<tag><marker id="type-encoding"/>encoding() = utf8 | unicode | latin1</tag>
<item><p/> </item>
<tag><marker id="type-erl_parse"/>erl_parse() = <seeerl marker="stdlib:erl_parse#type-abstract_clause">erl_parse:abstract_clause()</seeerl> | <seeerl marker="stdlib:erl_parse#type-abstract_expr">erl_parse:abstract_expr()</seeerl> | <seeerl marker="stdlib:erl_parse#type-abstract_form">erl_parse:abstract_form()</seeerl> | <seeerl marker="stdlib:erl_parse#type-abstract_type">erl_parse:abstract_type()</seeerl> | <seeerl marker="stdlib:erl_parse#type-form_info">erl_parse:form_info()</seeerl> | <seeerl marker="stdlib:erl_parse#type-af_binelement">erl_parse:af_binelement(term())</seeerl> | <seeerl marker="stdlib:erl_parse#type-af_generator">erl_parse:af_generator()</seeerl> | <seeerl marker="stdlib:erl_parse#type-af_remote_function">erl_parse:af_remote_function()</seeerl></tag>
<item><p/> </item>
<tag><marker id="type-forms"/>forms() = <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl> | [<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]</tag>
<item><p/> </item>
<tag><marker id="type-guard"/>guard() = none | <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl> | [<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>] | [[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]]</tag>
<item><p/> </item>
<tag><marker id="type-padding"/>padding() = none | integer()</tag>
<item><p/> </item>
<tag><marker id="type-syntaxTree"/>syntaxTree() = <seeerl marker="#type-tree">tree()</seeerl> | <seeerl marker="#type-wrapper">wrapper()</seeerl> | <seeerl marker="#type-erl_parse">erl_parse()</seeerl></tag>
<item><p/> </item>
<tag><marker id="type-syntaxTreeAttributes"/>syntaxTreeAttributes() = #attr{pos=term(), ann=[term()], com=none | #com{pre=[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>], post=[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]}}</tag>
<item><p/> </item>
<tag><marker id="type-tree"/>tree() = #tree{type=atom(), attr=#attr{pos=term(), ann=[term()], com=none | #com{pre=[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>], post=[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]}}, data=term()}</tag>
<item><p/> </item>
<tag><marker id="type-wrapper"/>wrapper() = #wrapper{type=atom(), attr=#attr{pos=term(), ann=[term()], com=none | #com{pre=[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>], post=[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]}}, tree=<seeerl marker="#type-erl_parse">erl_parse()</seeerl>}</tag>
<item><p/> </item>
</taglist></section>
<funcs>
<func>
<name since="">abstract(T::term()) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the syntax tree corresponding to an Erlang term.</fsummary>

<desc><marker id="abstract-1"/>

<p>Returns the syntax tree corresponding to an Erlang term.
  <c>Term</c> must be a literal term, i.e., one that can be
  represented as a source code literal. Thus, it may not contain a
  process identifier, port, reference or function value as a
  subterm. The function recognises printable strings, in order to get a
  compact and readable representation. Evaluation fails with reason
  <c>badarg</c> if <c>Term</c> is not a literal term.
 </p>
<p><em>See also:</em> <seemfa marker="#concrete/1">concrete/1</seemfa>, <seemfa marker="#is_literal/1">is_literal/1</seemfa>.</p>
</desc></func>
<func>
<name since="">add_ann(A::term(), Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Appends the term Annotation to the list of user
  annotations of Node.</fsummary>

<desc><marker id="add_ann-2"/>

<p>Appends the term <c>Annotation</c> to the list of user
  annotations of <c>Node</c>.</p>
 
  <p>Note: this is equivalent to <c>set_ann(Node, [Annotation |
  get_ann(Node)])</c>, but potentially more efficient.
 </p>
<p><em>See also:</em> <seemfa marker="#get_ann/1">get_ann/1</seemfa>, <seemfa marker="#set_ann/2">set_ann/2</seemfa>.</p>
</desc></func>
<func>
<name since="">add_postcomments(Cs::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>], Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Appends Comments to the post-comments of Node.</fsummary>

<desc><marker id="add_postcomments-2"/>

<p>Appends <c>Comments</c> to the post-comments of <c>Node</c>.</p>
 
  <p>Note: This is equivalent to <c>set_postcomments(Node,
  get_postcomments(Node) ++ Comments)</c>, but potentially more
  efficient.
 </p>
<p><em>See also:</em> <seemfa marker="#add_precomments/2">add_precomments/2</seemfa>, <seemfa marker="#comment/2">comment/2</seemfa>, <seemfa marker="#get_postcomments/1">get_postcomments/1</seemfa>, <seemfa marker="#join_comments/2">join_comments/2</seemfa>, <seemfa marker="#set_postcomments/2">set_postcomments/2</seemfa>.</p>
</desc></func>
<func>
<name since="">add_precomments(Cs::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>], Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Appends Comments to the pre-comments of Node.</fsummary>

<desc><marker id="add_precomments-2"/>

<p>Appends <c>Comments</c> to the pre-comments of <c>Node</c>.</p>
 
  <p>Note: This is equivalent to <c>set_precomments(Node,
  get_precomments(Node) ++ Comments)</c>, but potentially more
  efficient.
 </p>
<p><em>See also:</em> <seemfa marker="#add_postcomments/2">add_postcomments/2</seemfa>, <seemfa marker="#comment/2">comment/2</seemfa>, <seemfa marker="#get_precomments/1">get_precomments/1</seemfa>, <seemfa marker="#join_comments/2">join_comments/2</seemfa>, <seemfa marker="#set_precomments/2">set_precomments/2</seemfa>.</p>
</desc></func>
<func>
<name since="">annotated_type(Name::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Type::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract annotated type expression.</fsummary>

<desc><marker id="annotated_type-2"/>

<p>Creates an abstract annotated type expression. The result
  represents "<c>Name :: Type</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#annotated_type_body/1">annotated_type_body/1</seemfa>, <seemfa marker="#annotated_type_name/1">annotated_type_name/1</seemfa>.</p>
</desc></func>
<func>
<name since="">annotated_type_body(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the type subtrees of an annotated_type node.</fsummary>

<desc><marker id="annotated_type_body-1"/>

<p>Returns the type subtrees of an <c>annotated_type</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#annotated_type/2">annotated_type/2</seemfa>.</p>
</desc></func>
<func>
<name since="">annotated_type_name(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the name subtree of an annotated_type node.</fsummary>

<desc><marker id="annotated_type_name-1"/>

<p>Returns the name subtree of an <c>annotated_type</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#annotated_type/2">annotated_type/2</seemfa>.</p>
</desc></func>
<func>
<name since="">application(Operator::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Arguments::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract function application expression.</fsummary>

<desc><marker id="application-2"/>

<p>Creates an abstract function application expression. If
  <c>Arguments</c> is <c>[A1, ..., An]</c>, the result
  represents "<c>Operator(A1, ...,
  An)</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#application/3">application/3</seemfa>, <seemfa marker="#application_arguments/1">application_arguments/1</seemfa>, <seemfa marker="#application_operator/1">application_operator/1</seemfa>.</p>
</desc></func>
<func>
<name since="">application(Module::none | <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Name::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Arguments::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract function application expression.</fsummary>

<desc><marker id="application-3"/>

<p>Creates an abstract function application expression. If
  <c>Module</c> is <c>none</c>, this is call is equivalent
  to <c>application(Function, Arguments)</c>, otherwise it is
  equivalent to <c>application(module_qualifier(Module, Function),
  Arguments)</c>.</p>
 
  <p>(This is a utility function.)
 </p>
<p><em>See also:</em> <seemfa marker="#application/2">application/2</seemfa>, <seemfa marker="#module_qualifier/2">module_qualifier/2</seemfa>.</p>
</desc></func>
<func>
<name since="">application_arguments(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; [<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]</name>
<fsummary>Returns the list of argument subtrees of an
  application node.</fsummary>

<desc><marker id="application_arguments-1"/>

<p>Returns the list of argument subtrees of an
  <c>application</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#application/2">application/2</seemfa>.</p>
</desc></func>
<func>
<name since="">application_operator(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the operator subtree of an application node.</fsummary>

<desc><marker id="application_operator-1"/>

<p>Returns the operator subtree of an <c>application</c> node.</p>
 
  <p>Note: if <c>Node</c> represents
  "<c>M:F(...)</c>", then the result is the
  subtree representing "<c>M:F</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#application/2">application/2</seemfa>, <seemfa marker="#module_qualifier/2">module_qualifier/2</seemfa>.</p>
</desc></func>
<func>
<name since="">arity_qualifier(Body::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Arity::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract arity qualifier.</fsummary>

<desc><marker id="arity_qualifier-2"/>

<p>Creates an abstract arity qualifier. The result represents
  "<c>Body/Arity</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#arity_qualifier_argument/1">arity_qualifier_argument/1</seemfa>, <seemfa marker="#arity_qualifier_body/1">arity_qualifier_body/1</seemfa>.</p>
</desc></func>
<func>
<name since="">arity_qualifier_argument(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the argument (the arity) subtree of an
  arity_qualifier node.</fsummary>

<desc><marker id="arity_qualifier_argument-1"/>

<p>Returns the argument (the arity) subtree of an
  <c>arity_qualifier</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#arity_qualifier/2">arity_qualifier/2</seemfa>.</p>
</desc></func>
<func>
<name since="">arity_qualifier_body(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the body subtree of an arity_qualifier node.</fsummary>

<desc><marker id="arity_qualifier_body-1"/>

<p>Returns the body subtree of an <c>arity_qualifier</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#arity_qualifier/2">arity_qualifier/2</seemfa>.</p>
</desc></func>
<func>
<name since="">atom(Name::atom() | string()) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract atom literal.</fsummary>

<desc><marker id="atom-1"/>

<p>Creates an abstract atom literal. The print name of the atom is
  the character sequence represented by <c>Name</c>.
 </p>
<p><em>See also:</em> <seemfa marker="#atom_literal/1">atom_literal/1</seemfa>, <seemfa marker="#atom_literal/2">atom_literal/2</seemfa>, <seemfa marker="#atom_name/1">atom_name/1</seemfa>, <seemfa marker="#atom_value/1">atom_value/1</seemfa>, <seemfa marker="#is_atom/2">is_atom/2</seemfa>.</p>
</desc></func>
<func>
<name since="">atom_literal(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; string()</name>
<fsummary>Returns the literal string represented by an atom  
node.</fsummary>

<desc><marker id="atom_literal-1"/>

<p>Returns the literal string represented by an <c>atom</c>  
node. This includes surrounding single-quote characters if necessary.  
Characters beyond 255 will be escaped.</p>
 
  <p>Note that e.g. the result of <c>atom("x\ny")</c> represents
  any and all of `x\ny'', `x\12y'',
  `x\012y'' and `x\^Jy\''; see <seemfa marker="#string/1">string/1</seemfa>.
 </p>
<p><em>See also:</em> <seemfa marker="#atom/1">atom/1</seemfa>, <seemfa marker="#string/1">string/1</seemfa>.</p>
</desc></func>
<func>
<name since="">atom_literal(Node, X2) -&gt; term()
</name>
<fsummary>Returns the literal string represented by an atom
  node.</fsummary>

<desc><marker id="atom_literal-2"/>

<p>Returns the literal string represented by an <c>atom</c>
  node. This includes surrounding single-quote characters if necessary.
  Depending on the encoding a character beyond 255 will be escaped
  (<c>latin1</c>) or copied as is (<c>utf8</c>).
 </p>
<p><em>See also:</em> <seemfa marker="#atom/1">atom/1</seemfa>, <seemfa marker="#atom_literal/1">atom_literal/1</seemfa>, <seemfa marker="#string/1">string/1</seemfa>.</p>
</desc></func>
<func>
<name since="">atom_name(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; string()</name>
<fsummary>Returns the printname of an atom node.</fsummary>

<desc><marker id="atom_name-1"/>

<p>Returns the printname of an <c>atom</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#atom/1">atom/1</seemfa>.</p>
</desc></func>
<func>
<name since="">atom_value(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; atom()</name>
<fsummary>Returns the value represented by an atom node.</fsummary>

<desc><marker id="atom_value-1"/>

<p>Returns the value represented by an <c>atom</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#atom/1">atom/1</seemfa>.</p>
</desc></func>
<func>
<name since="">attribute(Name::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Equivalent to attribute(Name, none).
</fsummary>

<desc><marker id="attribute-1"/>
<p>Equivalent to <seemfa marker="#attribute/2">attribute(Name, none)</seemfa>.</p>
</desc></func>
<func>
<name since="">attribute(Name::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Args::none | [<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract program attribute.</fsummary>

<desc><marker id="attribute-2"/>

<p>Creates an abstract program attribute. If
  <c>Arguments</c> is <c>[A1, ..., An]</c>, the result
  represents "<c>-Name(A1, ...,
  An).</c>". Otherwise, if <c>Arguments</c> is
  <c>none</c>, the result represents
  "<c>-Name.</c>". The latter form makes it possible
  to represent preprocessor directives such as
  "<c>-endif.</c>". Attributes are source code forms.</p>
 
  <p>Note: The preprocessor macro definition directive
  "<c>-define(Name, Body).</c>" has relatively
  few requirements on the syntactical form of <c>Body</c> (viewed
  as a sequence of tokens). The <c>text</c> node type can be used
  for a <c>Body</c> that is not a normal Erlang construct.
 </p>
<p><em>See also:</em> <seemfa marker="#attribute/1">attribute/1</seemfa>, <seemfa marker="#attribute_arguments/1">attribute_arguments/1</seemfa>, <seemfa marker="#attribute_name/1">attribute_name/1</seemfa>, <seemfa marker="#is_form/1">is_form/1</seemfa>, <seemfa marker="#text/1">text/1</seemfa>.</p>
</desc></func>
<func>
<name since="">attribute_arguments(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; none | [<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]</name>
<fsummary>Returns the list of argument subtrees of an
  attribute node, if any.</fsummary>

<desc><marker id="attribute_arguments-1"/>

<p>Returns the list of argument subtrees of an
  <c>attribute</c> node, if any. If <c>Node</c>
  represents "<c>-Name.</c>", the result is
  <c>none</c>. Otherwise, if <c>Node</c> represents
  "<c>-Name(E1, ..., En).</c>",
  <c>[E1, ..., E1]</c> is returned.
 </p>
<p><em>See also:</em> <seemfa marker="#attribute/1">attribute/1</seemfa>.</p>
</desc></func>
<func>
<name since="">attribute_name(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the name subtree of an attribute node.</fsummary>

<desc><marker id="attribute_name-1"/>

<p>Returns the name subtree of an <c>attribute</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#attribute/1">attribute/1</seemfa>.</p>
</desc></func>
<func>
<name since="">binary(List::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract binary-object template.</fsummary>

<desc><marker id="binary-1"/>

<p>Creates an abstract binary-object template. If
  <c>Fields</c> is <c>[F1, ..., Fn]</c>, the result
  represents "<c>&lt;&lt;F1, ...,
  Fn&gt;&gt;</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#binary_field/2">binary_field/2</seemfa>, <seemfa marker="#binary_fields/1">binary_fields/1</seemfa>.</p>
</desc></func>
<func>
<name since="">binary_comp(Template::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Body::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract binary comprehension.</fsummary>

<desc><marker id="binary_comp-2"/>

<p>Creates an abstract binary comprehension. If <c>Body</c> is
  <c>[E1, ..., En]</c>, the result represents
  "<c>&lt;&lt;Template || E1, ..., En&gt;&gt;</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#binary_comp_body/1">binary_comp_body/1</seemfa>, <seemfa marker="#binary_comp_template/1">binary_comp_template/1</seemfa>, <seemfa marker="#generator/2">generator/2</seemfa>.</p>
</desc></func>
<func>
<name since="">binary_comp_body(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; [<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]</name>
<fsummary>Returns the list of body subtrees of a binary_comp node.</fsummary>

<desc><marker id="binary_comp_body-1"/>

<p>Returns the list of body subtrees of a <c>binary_comp</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#binary_comp/2">binary_comp/2</seemfa>.</p>
</desc></func>
<func>
<name since="">binary_comp_template(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the template subtree of a binary_comp node.</fsummary>

<desc><marker id="binary_comp_template-1"/>

<p>Returns the template subtree of a <c>binary_comp</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#binary_comp/2">binary_comp/2</seemfa>.</p>
</desc></func>
<func>
<name since="">binary_field(Body::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Equivalent to binary_field(Body, []).
</fsummary>

<desc><marker id="binary_field-1"/>
<p>Equivalent to <seemfa marker="#binary_field/2">binary_field(Body, [])</seemfa>.</p>
</desc></func>
<func>
<name since="">binary_field(Body::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Types::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract binary template field.</fsummary>

<desc><marker id="binary_field-2"/>

<p>Creates an abstract binary template field. If
  <c>Types</c> is the empty list, the result simply represents
  "<c>Body</c>", otherwise, if <c>Types</c> is
  <c>[T1, ..., Tn]</c>, the result represents
  "<c>Body/T1-...-Tn</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#binary/1">binary/1</seemfa>, <seemfa marker="#binary_field/1">binary_field/1</seemfa>, <seemfa marker="#binary_field/3">binary_field/3</seemfa>, <seemfa marker="#binary_field_body/1">binary_field_body/1</seemfa>, <seemfa marker="#binary_field_size/1">binary_field_size/1</seemfa>, <seemfa marker="#binary_field_types/1">binary_field_types/1</seemfa>.</p>
</desc></func>
<func>
<name since="">binary_field(Body::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Size::none | <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Types::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract binary template field.</fsummary>

<desc><marker id="binary_field-3"/>

<p>Creates an abstract binary template field.
  If <c>Size</c> is <c>none</c>, this is equivalent to
  "<c>binary_field(Body, Types)</c>", otherwise it is
  equivalent to "<c>binary_field(size_qualifier(Body, Size),
  Types)</c>".</p>
 
  <p>(This is a utility function.)
 </p>
<p><em>See also:</em> <seemfa marker="#binary/1">binary/1</seemfa>, <seemfa marker="#binary_field/2">binary_field/2</seemfa>, <seemfa marker="#size_qualifier/2">size_qualifier/2</seemfa>.</p>
</desc></func>
<func>
<name since="">binary_field_body(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the body subtree of a binary_field.</fsummary>

<desc><marker id="binary_field_body-1"/>

<p>Returns the body subtree of a <c>binary_field</c>.
 </p>
<p><em>See also:</em> <seemfa marker="#binary_field/2">binary_field/2</seemfa>.</p>
</desc></func>
<func>
<name since="">binary_field_size(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; none | <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the size specifier subtree of a
  binary_field node, if any.</fsummary>

<desc><marker id="binary_field_size-1"/>

<p>Returns the size specifier subtree of a
  <c>binary_field</c> node, if any. If <c>Node</c>
  represents "<c>Body:Size</c>" or
  "<c>Body:Size/T1, ...,
  Tn</c>", the result is <c>Size</c>, otherwise
  <c>none</c> is returned.</p>
 
  <p>(This is a utility function.)
 </p>
<p><em>See also:</em> <seemfa marker="#binary_field/2">binary_field/2</seemfa>, <seemfa marker="#binary_field/3">binary_field/3</seemfa>.</p>
</desc></func>
<func>
<name since="">binary_field_types(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; [<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]</name>
<fsummary>Returns the list of type-specifier subtrees of a
  binary_field node.</fsummary>

<desc><marker id="binary_field_types-1"/>

<p>Returns the list of type-specifier subtrees of a
  <c>binary_field</c> node. If <c>Node</c> represents
  "<c>.../T1, ..., Tn</c>", the result is
  <c>[T1, ..., Tn]</c>, otherwise the result is the empty list.
 </p>
<p><em>See also:</em> <seemfa marker="#binary_field/2">binary_field/2</seemfa>.</p>
</desc></func>
<func>
<name since="">binary_fields(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; [<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]</name>
<fsummary>Returns the list of field subtrees of a binary node.</fsummary>

<desc><marker id="binary_fields-1"/>

<p>Returns the list of field subtrees of a <c>binary</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#binary/1">binary/1</seemfa>, <seemfa marker="#binary_field/2">binary_field/2</seemfa>.</p>
</desc></func>
<func>
<name since="">binary_generator(Pattern::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Body::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract binary_generator.</fsummary>

<desc><marker id="binary_generator-2"/>

<p>Creates an abstract binary_generator. The result represents
  "<c>Pattern &lt;- Body</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#binary_comp/2">binary_comp/2</seemfa>, <seemfa marker="#binary_generator_body/1">binary_generator_body/1</seemfa>, <seemfa marker="#binary_generator_pattern/1">binary_generator_pattern/1</seemfa>, <seemfa marker="#list_comp/2">list_comp/2</seemfa>.</p>
</desc></func>
<func>
<name since="">binary_generator_body(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the body subtree of a generator node.</fsummary>

<desc><marker id="binary_generator_body-1"/>

<p>Returns the body subtree of a <c>generator</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#binary_generator/2">binary_generator/2</seemfa>.</p>
</desc></func>
<func>
<name since="">binary_generator_pattern(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the pattern subtree of a generator node.</fsummary>

<desc><marker id="binary_generator_pattern-1"/>

<p>Returns the pattern subtree of a <c>generator</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#binary_generator/2">binary_generator/2</seemfa>.</p>
</desc></func>
<func>
<name since="">bitstring_type(M::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, N::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract bitstring type.</fsummary>

<desc><marker id="bitstring_type-2"/>

<p>Creates an abstract bitstring type. The result represents
  "<c>&lt;&lt;_:M, _:_*N&gt;&gt;</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#bitstring_type_m/1">bitstring_type_m/1</seemfa>, <seemfa marker="#bitstring_type_n/1">bitstring_type_n/1</seemfa>.</p>
</desc></func>
<func>
<name since="">bitstring_type_m(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the number of start bits, M,  of a bitstring_type node.</fsummary>

<desc><marker id="bitstring_type_m-1"/>

<p>Returns the number of start bits, <c>M</c>,  of a <c>bitstring_type</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#bitstring_type/2">bitstring_type/2</seemfa>.</p>
</desc></func>
<func>
<name since="">bitstring_type_n(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the segment size, N, of a bitstring_type node.</fsummary>

<desc><marker id="bitstring_type_n-1"/>

<p>Returns the segment size, <c>N</c>, of a <c>bitstring_type</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#bitstring_type/2">bitstring_type/2</seemfa>.</p>
</desc></func>
<func>
<name since="">block_expr(Body::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract block expression.</fsummary>

<desc><marker id="block_expr-1"/>

<p>Creates an abstract block expression. If <c>Body</c> is
  <c>[B1, ..., Bn]</c>, the result represents "<c>begin
  B1, ..., Bn end</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#block_expr_body/1">block_expr_body/1</seemfa>.</p>
</desc></func>
<func>
<name since="">block_expr_body(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; [<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]</name>
<fsummary>Returns the list of body subtrees of a block_expr node.</fsummary>

<desc><marker id="block_expr_body-1"/>

<p>Returns the list of body subtrees of a <c>block_expr</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#block_expr/1">block_expr/1</seemfa>.</p>
</desc></func>
<func>
<name since="">case_expr(Argument::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Clauses::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract case-expression.</fsummary>

<desc><marker id="case_expr-2"/>

<p>Creates an abstract case-expression. If <c>Clauses</c> is
  <c>[C1, ..., Cn]</c>, the result represents "<c>case
  Argument of C1; ...; Cn end</c>". More
  exactly, if each <c>Ci</c> represents "<c>(Pi)
  Gi -&gt; Bi</c>", then the result represents
  "<c>case Argument of P1 G1 -&gt;
  B1; ...; Pn Gn -&gt; Bn end</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#case_expr_argument/1">case_expr_argument/1</seemfa>, <seemfa marker="#case_expr_clauses/1">case_expr_clauses/1</seemfa>, <seemfa marker="#clause/3">clause/3</seemfa>, <seemfa marker="#if_expr/1">if_expr/1</seemfa>.</p>
</desc></func>
<func>
<name since="">case_expr_argument(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the argument subtree of a case_expr node.</fsummary>

<desc><marker id="case_expr_argument-1"/>

<p>Returns the argument subtree of a <c>case_expr</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#case_expr/2">case_expr/2</seemfa>.</p>
</desc></func>
<func>
<name since="">case_expr_clauses(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; [<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]</name>
<fsummary>Returns the list of clause subtrees of a case_expr node.</fsummary>

<desc><marker id="case_expr_clauses-1"/>

<p>Returns the list of clause subtrees of a <c>case_expr</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#case_expr/2">case_expr/2</seemfa>.</p>
</desc></func>
<func>
<name since="">catch_expr(Expr::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract catch-expression.</fsummary>

<desc><marker id="catch_expr-1"/>

<p>Creates an abstract catch-expression. The result represents
  "<c>catch Expr</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#catch_expr_body/1">catch_expr_body/1</seemfa>.</p>
</desc></func>
<func>
<name since="">catch_expr_body(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the body subtree of a catch_expr node.</fsummary>

<desc><marker id="catch_expr_body-1"/>

<p>Returns the body subtree of a <c>catch_expr</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#catch_expr/1">catch_expr/1</seemfa>.</p>
</desc></func>
<func>
<name since="">char(Char::char()) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract character literal.</fsummary>

<desc><marker id="char-1"/>

<p>Creates an abstract character literal. The result represents
  "<c>$Name</c>", where <c>Name</c> corresponds to
  <c>Value</c>.</p>
 
  <p>Note: the literal corresponding to a particular character value is
  not uniquely defined. E.g., the character "<c>a</c>" can be
  written both as "<c>$a</c>" and "<c>$\141</c>", and a Tab
  character can be written as "<c>$\11</c>", "<c>$\011</c>"
  or "<c>$\t</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#char_literal/1">char_literal/1</seemfa>, <seemfa marker="#char_literal/2">char_literal/2</seemfa>, <seemfa marker="#char_value/1">char_value/1</seemfa>, <seemfa marker="#is_char/2">is_char/2</seemfa>.</p>
</desc></func>
<func>
<name since="">char_literal(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; nonempty_string()</name>
<fsummary>Returns the literal string represented by a char
  node.</fsummary>

<desc><marker id="char_literal-1"/>

<p>Returns the literal string represented by a <c>char</c>
  node. This includes the leading "<c>$</c>" character.
  Characters beyond 255 will be escaped.
 </p>
<p><em>See also:</em> <seemfa marker="#char/1">char/1</seemfa>.</p>
</desc></func>
<func>
<name since="">char_literal(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, X2::<seeerl marker="#type-encoding">encoding()</seeerl>) -&gt; nonempty_string()</name>
<fsummary>Returns the literal string represented by a char
  node.</fsummary>

<desc><marker id="char_literal-2"/>

<p>Returns the literal string represented by a <c>char</c>
  node. This includes the leading "<c>$</c>" character.
  Depending on the encoding a character beyond 255 will be escaped
  (<c>latin1</c>) or copied as is (<c>utf8</c>).
 </p>
<p><em>See also:</em> <seemfa marker="#char/1">char/1</seemfa>.</p>
</desc></func>
<func>
<name since="">char_value(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; char()</name>
<fsummary>Returns the value represented by a char node.</fsummary>

<desc><marker id="char_value-1"/>

<p>Returns the value represented by a <c>char</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#char/1">char/1</seemfa>.</p>
</desc></func>
<func>
<name since="">class_qualifier(Class::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Body::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract class qualifier.</fsummary>

<desc><marker id="class_qualifier-2"/>

<p>Creates an abstract class qualifier. The result represents
  "<c>Class:Body</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#class_qualifier_argument/1">class_qualifier_argument/1</seemfa>, <seemfa marker="#class_qualifier_body/1">class_qualifier_body/1</seemfa>, <seemfa marker="#class_qualifier_stacktrace/1">class_qualifier_stacktrace/1</seemfa>, <seemfa marker="#try_expr/4">try_expr/4</seemfa>.</p>
</desc></func>
<func>
<name since="">class_qualifier(Class::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Body::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Stacktrace::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract class qualifier.</fsummary>

<desc><marker id="class_qualifier-3"/>

<p>Creates an abstract class qualifier. The result represents
  "<c>Class:Body:Stacktrace</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#class_qualifier_argument/1">class_qualifier_argument/1</seemfa>, <seemfa marker="#class_qualifier_body/1">class_qualifier_body/1</seemfa>, <seemfa marker="#try_expr/4">try_expr/4</seemfa>.</p>
</desc></func>
<func>
<name since="">class_qualifier_argument(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the argument (the class) subtree of a
  class_qualifier node.</fsummary>

<desc><marker id="class_qualifier_argument-1"/>

<p>Returns the argument (the class) subtree of a
  <c>class_qualifier</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#class_qualifier/2">class_qualifier/2</seemfa>.</p>
</desc></func>
<func>
<name since="">class_qualifier_body(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the body subtree of a class_qualifier node.</fsummary>

<desc><marker id="class_qualifier_body-1"/>

<p>Returns the body subtree of a <c>class_qualifier</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#class_qualifier/2">class_qualifier/2</seemfa>.</p>
</desc></func>
<func>
<name since="">class_qualifier_stacktrace(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the stacktrace subtree of a class_qualifier node.</fsummary>

<desc><marker id="class_qualifier_stacktrace-1"/>

<p>Returns the stacktrace subtree of a <c>class_qualifier</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#class_qualifier/2">class_qualifier/2</seemfa>.</p>
</desc></func>
<func>
<name since="">clause(Guard::<seeerl marker="#type-guard">guard()</seeerl>, Body::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Equivalent to clause([], Guard, Body).
</fsummary>

<desc><marker id="clause-2"/>
<p>Equivalent to <seemfa marker="#clause/3">clause([], Guard, Body)</seemfa>.</p>
</desc></func>
<func>
<name since="">clause(Patterns::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>], Guard::<seeerl marker="#type-guard">guard()</seeerl>, Body::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract clause.</fsummary>

<desc><marker id="clause-3"/>

<p>Creates an abstract clause. If <c>Patterns</c> is
  <c>[P1, ..., Pn]</c> and <c>Body</c> is <c>[B1, ...,
  Bm]</c>, then if <c>Guard</c> is <c>none</c>, the
  result represents "<c>(P1, ..., Pn) -&gt;
  B1, ..., Bm</c>", otherwise, unless
  <c>Guard</c> is a list, the result represents
  "<c>(P1, ..., Pn) when Guard -&gt;
  B1, ..., Bm</c>".</p>
 
  <p>For simplicity, the <c>Guard</c> argument may also be any
  of the following:
  </p><list>
    <item><p>An empty list <c>[]</c>. This is equivalent to passing
        <c>none</c>.</p></item>
    <item><p>A nonempty list <c>[E1, ..., Ej]</c> of syntax trees.
        This is equivalent to passing <c>conjunction([E1, ...,
        Ej])</c>.</p></item>
    <item><p>A nonempty list of lists of syntax trees <c>[[E1_1, ...,
        E1_k1], ..., [Ej_1, ..., Ej_kj]]</c>, which is equivalent
        to passing <c>disjunction([conjunction([E1_1, ...,
        E1_k1]), ..., conjunction([Ej_1, ..., Ej_kj])])</c>.</p></item>
  </list><p>
 </p>
<p><em>See also:</em> <seemfa marker="#clause/2">clause/2</seemfa>, <seemfa marker="#clause_body/1">clause_body/1</seemfa>, <seemfa marker="#clause_guard/1">clause_guard/1</seemfa>, <seemfa marker="#clause_patterns/1">clause_patterns/1</seemfa>.</p>
</desc></func>
<func>
<name since="">clause_body(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; [<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]</name>
<fsummary>Return the list of body subtrees of a clause node.</fsummary>

<desc><marker id="clause_body-1"/>

<p>Return the list of body subtrees of a <c>clause</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#clause/3">clause/3</seemfa>.</p>
</desc></func>
<func>
<name since="">clause_guard(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; none | <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the guard subtree of a clause node, if
  any.</fsummary>

<desc><marker id="clause_guard-1"/>

<p>Returns the guard subtree of a <c>clause</c> node, if
  any. If <c>Node</c> represents "<c>(P1, ...,
  Pn) when Guard -&gt; B1, ...,
  Bm</c>", <c>Guard</c> is returned. Otherwise, the
  result is <c>none</c>.
 </p>
<p><em>See also:</em> <seemfa marker="#clause/3">clause/3</seemfa>.</p>
</desc></func>
<func>
<name since="">clause_patterns(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; [<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]</name>
<fsummary>Returns the list of pattern subtrees of a clause node.</fsummary>

<desc><marker id="clause_patterns-1"/>

<p>Returns the list of pattern subtrees of a <c>clause</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#clause/3">clause/3</seemfa>.</p>
</desc></func>
<func>
<name since="">comment(Strings::[string()]) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Equivalent to comment(none, Strings).
</fsummary>

<desc><marker id="comment-1"/>
<p>Equivalent to <seemfa marker="#comment/2">comment(none, Strings)</seemfa>.</p>
</desc></func>
<func>
<name since="">comment(Pad::<seeerl marker="#type-padding">padding()</seeerl>, Strings::[string()]) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract comment with the given padding and text.</fsummary>

<desc><marker id="comment-2"/>

<p>Creates an abstract comment with the given padding and text. If
  <c>Strings</c> is a (possibly empty) list
  <c>["Txt1", ..., "TxtN"]</c>, the result
  represents the source code text
  </p><pre>
     %Txt1
     ...
     %TxtN</pre><p>
  <c>Padding</c> states the number of empty character positions
  to the left of the comment separating it horizontally from
  source code on the same line (if any). If <c>Padding</c> is
  <c>none</c>, a default positive number is used. If
  <c>Padding</c> is an integer less than 1, there should be no
  separating space. Comments are in themselves regarded as source
  program forms.
 </p>
<p><em>See also:</em> <seemfa marker="#comment/1">comment/1</seemfa>, <seemfa marker="#is_form/1">is_form/1</seemfa>.</p>
</desc></func>
<func>
<name since="">comment_padding(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-padding">padding()</seeerl></name>
<fsummary>Returns the amount of padding before the comment, or
  none.</fsummary>

<desc><marker id="comment_padding-1"/>

<p>Returns the amount of padding before the comment, or
  <c>none</c>. The latter means that a default padding may be used.
 </p>
<p><em>See also:</em> <seemfa marker="#comment/2">comment/2</seemfa>.</p>
</desc></func>
<func>
<name since="">comment_text(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; [string()]</name>
<fsummary>Returns the lines of text of the abstract comment.</fsummary>

<desc><marker id="comment_text-1"/>

<p>Returns the lines of text of the abstract comment.
 </p>
<p><em>See also:</em> <seemfa marker="#comment/2">comment/2</seemfa>.</p>
</desc></func>
<func>
<name since="">compact_list(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Yields the most compact form for an abstract list skeleton.</fsummary>

<desc><marker id="compact_list-1"/>

<p>Yields the most compact form for an abstract list skeleton. The
  result either represents "<c>[E1, ..., En |
  Tail]</c>", where <c>Tail</c> is not a list
  skeleton, or otherwise simply "<c>[E1, ...,
  En]</c>". Annotations on subtrees of <c>Node</c>
  that represent list skeletons may be lost, but comments will be
  propagated to the result. Returns <c>Node</c> itself if
  <c>Node</c> does not represent a list skeleton.
 </p>
<p><em>See also:</em> <seemfa marker="#list/2">list/2</seemfa>, <seemfa marker="#normalize_list/1">normalize_list/1</seemfa>.</p>
</desc></func>
<func>
<name since="">concrete(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; term()</name>
<fsummary>Returns the Erlang term represented by a syntax tree.</fsummary>

<desc><marker id="concrete-1"/>

<p>Returns the Erlang term represented by a syntax tree. Evaluation
  fails with reason <c>badarg</c> if <c>Node</c> does not  
represent a literal term.</p>
 
  <p>Note: Currently, the set of syntax trees which have a concrete
  representation is larger than the set of trees which can be built
  using the function <seemfa marker="#abstract/1">abstract/1</seemfa>. An abstract character
  will be concretised as an integer, while <seemfa marker="#abstract/1">abstract/1</seemfa> does
  not at present yield an abstract character for any input. (Use the
  <seemfa marker="#char/1">char/1</seemfa> function to explicitly create an abstract  
character.)</p>
 
  <p>Note: <c>arity_qualifier</c> nodes are recognized. This is to follow The
  Erlang Parser when it comes to wild attributes: both {F, A} and F/A
  are recognized, which makes it possible to turn wild attributes
  into recognized attributes without at the same time making it
  impossible to compile files using the new syntax with the old
  version of the Erlang Compiler.
 </p>
<p><em>See also:</em> <seemfa marker="#abstract/1">abstract/1</seemfa>, <seemfa marker="#char/1">char/1</seemfa>, <seemfa marker="#is_literal/1">is_literal/1</seemfa>.</p>
</desc></func>
<func>
<name since="">conjunction(Tests::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract conjunction.</fsummary>

<desc><marker id="conjunction-1"/>

<p>Creates an abstract conjunction. If <c>List</c> is
  <c>[E1, ..., En]</c>, the result represents
  "<c>E1, ..., En</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#conjunction_body/1">conjunction_body/1</seemfa>, <seemfa marker="#disjunction/1">disjunction/1</seemfa>.</p>
</desc></func>
<func>
<name since="">conjunction_body(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; [<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]</name>
<fsummary>Returns the list of body subtrees of a
  conjunction node.</fsummary>

<desc><marker id="conjunction_body-1"/>

<p>Returns the list of body subtrees of a
  <c>conjunction</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#conjunction/1">conjunction/1</seemfa>.</p>
</desc></func>
<func>
<name since="">cons(Head::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Tail::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>"Optimising" list skeleton cons operation.</fsummary>

<desc><marker id="cons-2"/>

<p>"Optimising" list skeleton cons operation. Creates an abstract
  list skeleton whose first element is <c>Head</c> and whose tail
  corresponds to <c>Tail</c>. This is similar to
  <c>list([Head], Tail)</c>, except that <c>Tail</c> may
  not be <c>none</c>, and that the result does not necessarily
  represent exactly "<c>[Head | Tail]</c>", but
  may depend on the <c>Tail</c> subtree. E.g., if
  <c>Tail</c> represents <c>[X, Y]</c>, the result may
  represent "<c>[Head, X, Y]</c>", rather than
  "<c>[Head | [X, Y]]</c>". Annotations on
  <c>Tail</c> itself may be lost if <c>Tail</c> represents
  a list skeleton, but comments on <c>Tail</c> are propagated to
  the result.
 </p>
<p><em>See also:</em> <seemfa marker="#list/2">list/2</seemfa>, <seemfa marker="#list_head/1">list_head/1</seemfa>, <seemfa marker="#list_tail/1">list_tail/1</seemfa>.</p>
</desc></func>
<func>
<name since="">constrained_function_type(FunctionType::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, FunctionConstraint::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract constrained function type.</fsummary>

<desc><marker id="constrained_function_type-2"/>

<p>Creates an abstract constrained function type.
  If <c>FunctionConstraint</c> is <c>[C1, ..., Cn]</c>, the result represents
  "<c>FunctionType when C1, ...Cn</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#constrained_function_type_argument/1">constrained_function_type_argument/1</seemfa>, <seemfa marker="#constrained_function_type_body/1">constrained_function_type_body/1</seemfa>.</p>
</desc></func>
<func>
<name since="">constrained_function_type_argument(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the function constraint subtree of a
  constrained_function_type node.</fsummary>

<desc><marker id="constrained_function_type_argument-1"/>

<p>Returns the function constraint subtree of a
  <c>constrained_function_type</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#constrained_function_type/2">constrained_function_type/2</seemfa>.</p>
</desc></func>
<func>
<name since="">constrained_function_type_body(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the function type subtree of a
  constrained_function_type node.</fsummary>

<desc><marker id="constrained_function_type_body-1"/>

<p>Returns the function type subtree of a
  <c>constrained_function_type</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#constrained_function_type/2">constrained_function_type/2</seemfa>.</p>
</desc></func>
<func>
<name since="">constraint(Name::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Types::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract (subtype) constraint.</fsummary>

<desc><marker id="constraint-2"/>

<p>Creates an abstract (subtype) constraint. The result represents
  "<c>Name :: Type</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#constraint_argument/1">constraint_argument/1</seemfa>, <seemfa marker="#constraint_body/1">constraint_body/1</seemfa>.</p>
</desc></func>
<func>
<name since="">constraint_argument(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the name subtree of a constraint node.</fsummary>

<desc><marker id="constraint_argument-1"/>

<p>Returns the name subtree of a <c>constraint</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#constraint/2">constraint/2</seemfa>.</p>
</desc></func>
<func>
<name since="">constraint_body(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; [<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]</name>
<fsummary>Returns the type subtree of a constraint node.</fsummary>

<desc><marker id="constraint_body-1"/>

<p>Returns the type subtree of a <c>constraint</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#constraint/2">constraint/2</seemfa>.</p>
</desc></func>
<func>
<name since="">copy_ann(Source::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Target::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Copies the list of user annotations from Source to Target.</fsummary>

<desc><marker id="copy_ann-2"/>

<p>Copies the list of user annotations from <c>Source</c> to <c>Target</c>.</p>
 
  <p>Note: this is equivalent to <c>set_ann(Target,
  get_ann(Source))</c>, but potentially more efficient.
 </p>
<p><em>See also:</em> <seemfa marker="#get_ann/1">get_ann/1</seemfa>, <seemfa marker="#set_ann/2">set_ann/2</seemfa>.</p>
</desc></func>
<func>
<name since="">copy_attrs(S::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, T::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Copies the attributes from Source to Target.</fsummary>

<desc><marker id="copy_attrs-2"/>

<p>Copies the attributes from <c>Source</c> to <c>Target</c>.</p>
 
  <p>Note: this is equivalent to <c>set_attrs(Target,
  get_attrs(Source))</c>, but potentially more efficient.
 </p>
<p><em>See also:</em> <seemfa marker="#get_attrs/1">get_attrs/1</seemfa>, <seemfa marker="#set_attrs/2">set_attrs/2</seemfa>.</p>
</desc></func>
<func>
<name since="">copy_comments(Source::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Target::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Copies the pre- and postcomments from Source to Target.</fsummary>

<desc><marker id="copy_comments-2"/>

<p>Copies the pre- and postcomments from <c>Source</c> to <c>Target</c>.</p>
 
  <p>Note: This is equivalent to
  <c>set_postcomments(set_precomments(Target,
  get_precomments(Source)), get_postcomments(Source))</c>, but
  potentially more efficient.
 </p>
<p><em>See also:</em> <seemfa marker="#comment/2">comment/2</seemfa>, <seemfa marker="#get_postcomments/1">get_postcomments/1</seemfa>, <seemfa marker="#get_precomments/1">get_precomments/1</seemfa>, <seemfa marker="#set_postcomments/2">set_postcomments/2</seemfa>, <seemfa marker="#set_precomments/2">set_precomments/2</seemfa>.</p>
</desc></func>
<func>
<name since="">copy_pos(Source::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Target::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Copies the annotation from Source to Target.</fsummary>

<desc><marker id="copy_pos-2"/>

<p>Copies the annotation from <c>Source</c> to <c>Target</c>.</p>
 
  <p>This is equivalent to <c>set_pos(Target,
  get_pos(Source))</c>, but potentially more efficient.
 </p>
<p><em>See also:</em> <seemfa marker="#get_pos/1">get_pos/1</seemfa>, <seemfa marker="#set_pos/2">set_pos/2</seemfa>.</p>
</desc></func>
<func>
<name since="">data(Tree::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; term()</name>
<fsummary>For special purposes only.</fsummary>

<desc><marker id="data-1"/>

<p><em>For special purposes only</em>. Returns the associated data
  of a syntax tree node. Evaluation fails with reason
  <c>badarg</c> if <c>is_tree(Node)</c> does not yield
  <c>true</c>.
 </p>
<p><em>See also:</em> <seemfa marker="#tree/2">tree/2</seemfa>.</p>
</desc></func>
<func>
<name since="">disjunction(Tests::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract disjunction.</fsummary>

<desc><marker id="disjunction-1"/>

<p>Creates an abstract disjunction. If <c>List</c> is
  <c>[E1, ..., En]</c>, the result represents
  "<c>E1; ...; En</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#conjunction/1">conjunction/1</seemfa>, <seemfa marker="#disjunction_body/1">disjunction_body/1</seemfa>.</p>
</desc></func>
<func>
<name since="">disjunction_body(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; [<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]</name>
<fsummary>Returns the list of body subtrees of a
  disjunction node.</fsummary>

<desc><marker id="disjunction_body-1"/>

<p>Returns the list of body subtrees of a
  <c>disjunction</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#disjunction/1">disjunction/1</seemfa>.</p>
</desc></func>
<func>
<name since="">else_expr(Clauses) -&gt; term()
</name>
<fsummary>Creates an abstract else-expression.</fsummary>

<desc><marker id="else_expr-1"/>

<p>Creates an abstract else-expression. If <c>Clauses</c> is <c>[C1,
  ..., Cn]</c>, the result represents "<c>else C1; ...; Cn
  end</c>". More exactly, if each <c>Ci</c> represents
  "<c>(Pi) Gi -&gt; Bi</c>", then the
  result represents "<c>else G1 -&gt; B1; ...;
  Pn Gn -&gt; Bn end</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#clause/3">clause/3</seemfa>, <seemfa marker="#else_expr_clauses/1">else_expr_clauses/1</seemfa>, <seemfa marker="#maybe_expr/2">maybe_expr/2</seemfa>.</p>
</desc></func>
<func>
<name since="">else_expr_clauses(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; [<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]</name>
<fsummary>Returns the list of clause subtrees of an else_expr node.</fsummary>

<desc><marker id="else_expr_clauses-1"/>

<p>Returns the list of clause subtrees of an <c>else_expr</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#else_expr/1">else_expr/1</seemfa>.</p>
</desc></func>
<func>
<name since="">eof_marker() -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract end-of-file marker.</fsummary>

<desc><marker id="eof_marker-0"/>

<p>Creates an abstract end-of-file marker. This represents the  
end of input when reading a sequence of source code forms. An  
end-of-file marker is itself regarded as a source code form  
(namely, the last in any sequence in which it occurs). It has no  
defined lexical form.</p>
 
  <p>Note: this is retained only for backwards compatibility with
  existing parsers and tools.
 </p>
<p><em>See also:</em> <seemfa marker="#error_marker/1">error_marker/1</seemfa>, <seemfa marker="#is_form/1">is_form/1</seemfa>, <seemfa marker="#warning_marker/1">warning_marker/1</seemfa>.</p>
</desc></func>
<func>
<name since="">error_marker(Error::term()) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract error marker.</fsummary>

<desc><marker id="error_marker-1"/>

<p>Creates an abstract error marker. The result represents an
  occurrence of an error in the source code, with an associated Erlang
  I/O ErrorInfo structure given by <c>Error</c> (see module
  <seeerl marker="stdlib:io">io(3)</seeerl> for details). Error markers are regarded as source  
code forms, but have no defined lexical form.</p>
 
  <p>Note: this is supported only for backwards compatibility with
  existing parsers and tools.
 </p>
<p><em>See also:</em> <seemfa marker="#eof_marker/0">eof_marker/0</seemfa>, <seemfa marker="#error_marker_info/1">error_marker_info/1</seemfa>, <seemfa marker="#is_form/1">is_form/1</seemfa>, <seemfa marker="#warning_marker/1">warning_marker/1</seemfa>.</p>
</desc></func>
<func>
<name since="">error_marker_info(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; term()</name>
<fsummary>Returns the ErrorInfo structure of an error_marker node.</fsummary>

<desc><marker id="error_marker_info-1"/>

<p>Returns the ErrorInfo structure of an <c>error_marker</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#error_marker/1">error_marker/1</seemfa>.</p>
</desc></func>
<func>
<name since="">flatten_form_list(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Flattens sublists of a form_list node.</fsummary>

<desc><marker id="flatten_form_list-1"/>

<p>Flattens sublists of a <c>form_list</c> node. Returns
  <c>Node</c> with all subtrees of type <c>form_list</c>
  recursively expanded, yielding a single "flat" abstract form
  sequence.
 </p>
<p><em>See also:</em> <seemfa marker="#form_list/1">form_list/1</seemfa>.</p>
</desc></func>
<func>
<name since="">float(Value::float()) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract floating-point literal.</fsummary>

<desc><marker id="float-1"/>

<p>Creates an abstract floating-point literal. The lexical
  representation is the decimal floating-point numeral of <c>Value</c>.
 </p>
<p><em>See also:</em> <seemfa marker="#float_literal/1">float_literal/1</seemfa>, <seemfa marker="#float_value/1">float_value/1</seemfa>.</p>
</desc></func>
<func>
<name since="">float_literal(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; string()</name>
<fsummary>Returns the numeral string represented by a float node.</fsummary>

<desc><marker id="float_literal-1"/>

<p>Returns the numeral string represented by a <c>float</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#float/1">float/1</seemfa>.</p>
</desc></func>
<func>
<name since="">float_value(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; float()</name>
<fsummary>Returns the value represented by a float node.</fsummary>

<desc><marker id="float_value-1"/>

<p>Returns the value represented by a <c>float</c> node. Note
  that floating-point values should usually not be compared for
  equality.
 </p>
<p><em>See also:</em> <seemfa marker="#float/1">float/1</seemfa>.</p>
</desc></func>
<func>
<name since="">form_list(Forms::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract sequence of "source code forms".</fsummary>

<desc><marker id="form_list-1"/>

<p>Creates an abstract sequence of "source code forms". If
  <c>Forms</c> is <c>[F1, ..., Fn]</c>, where each
  <c>Fi</c> is a form (see <seemfa marker="#is_form/1">is_form/1</seemfa>, the result
  represents
  </p><pre>
     F1
     ...
     Fn</pre><p>
  where the <c>Fi</c> are separated by one or more line breaks. A
  node of type <c>form_list</c> is itself regarded as a source
  code form; see <seemfa marker="#flatten_form_list/1">flatten_form_list/1</seemfa>.</p>
 
  <p>Note: this is simply a way of grouping source code forms as a
  single syntax tree, usually in order to form an Erlang module
  definition.
 </p>
<p><em>See also:</em> <seemfa marker="#flatten_form_list/1">flatten_form_list/1</seemfa>, <seemfa marker="#form_list_elements/1">form_list_elements/1</seemfa>, <seemfa marker="#is_form/1">is_form/1</seemfa>.</p>
</desc></func>
<func>
<name since="">form_list_elements(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; [<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]</name>
<fsummary>Returns the list of subnodes of a form_list node.</fsummary>

<desc><marker id="form_list_elements-1"/>

<p>Returns the list of subnodes of a <c>form_list</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#form_list/1">form_list/1</seemfa>.</p>
</desc></func>
<func>
<name since="">fun_expr(Clauses::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract fun-expression.</fsummary>

<desc><marker id="fun_expr-1"/>

<p>Creates an abstract fun-expression. If <c>Clauses</c> is
  <c>[C1, ..., Cn]</c>, the result represents "<c>fun
  C1; ...; Cn end</c>". More exactly, if each
  <c>Ci</c> represents "<c>(Pi1, ..., Pim)
  Gi -&gt; Bi</c>", then the result represents
  "<c>fun (P11, ..., P1m) G1 -&gt;
  B1; ...; (Pn1, ..., Pnm) Gn -&gt;
  Bn end</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#fun_expr_arity/1">fun_expr_arity/1</seemfa>, <seemfa marker="#fun_expr_clauses/1">fun_expr_clauses/1</seemfa>.</p>
</desc></func>
<func>
<name since="">fun_expr_arity(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; arity()</name>
<fsummary>Returns the arity of a fun_expr node.</fsummary>

<desc><marker id="fun_expr_arity-1"/>

<p>Returns the arity of a <c>fun_expr</c> node. The result is  
the number of parameter patterns in the first clause of the  
fun-expression; subsequent clauses are ignored.</p>
 
  <p>An exception is thrown if <c>fun_expr_clauses(Node)</c>
  returns an empty list, or if the first element of that list is not a
  syntax tree <c>C</c> of type <c>clause</c> such that
  <c>clause_patterns(C)</c> is a nonempty list.
 </p>
<p><em>See also:</em> <seemfa marker="#clause/3">clause/3</seemfa>, <seemfa marker="#clause_patterns/1">clause_patterns/1</seemfa>, <seemfa marker="#fun_expr/1">fun_expr/1</seemfa>, <seemfa marker="#fun_expr_clauses/1">fun_expr_clauses/1</seemfa>.</p>
</desc></func>
<func>
<name since="">fun_expr_clauses(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; [<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]</name>
<fsummary>Returns the list of clause subtrees of a fun_expr node.</fsummary>

<desc><marker id="fun_expr_clauses-1"/>

<p>Returns the list of clause subtrees of a <c>fun_expr</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#fun_expr/1">fun_expr/1</seemfa>.</p>
</desc></func>
<func>
<name since="">fun_type() -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract fun of any type.</fsummary>

<desc><marker id="fun_type-0"/>

<p>Creates an abstract fun of any type. The result represents
  "<c>fun()</c>".</p>
</desc></func>
<func>
<name since="">function(Name::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Clauses::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract function definition.</fsummary>

<desc><marker id="function-2"/>

<p>Creates an abstract function definition. If <c>Clauses</c>
  is <c>[C1, ..., Cn]</c>, the result represents
  "<c>Name C1; ...; Name
  Cn.</c>". More exactly, if each <c>Ci</c>
  represents "<c>(Pi1, ..., Pim) Gi -&gt;
  Bi</c>", then the result represents
  "<c>Name(P11, ..., P1m) G1 -&gt;
  B1; ...; Name(Pn1, ..., Pnm)
  Gn -&gt; Bn.</c>". Function definitions are source
  code forms.
 </p>
<p><em>See also:</em> <seemfa marker="#function_arity/1">function_arity/1</seemfa>, <seemfa marker="#function_clauses/1">function_clauses/1</seemfa>, <seemfa marker="#function_name/1">function_name/1</seemfa>, <seemfa marker="#is_form/1">is_form/1</seemfa>.</p>
</desc></func>
<func>
<name since="">function_arity(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; arity()</name>
<fsummary>Returns the arity of a function node.</fsummary>

<desc><marker id="function_arity-1"/>

<p>Returns the arity of a <c>function</c> node. The result  
is the number of parameter patterns in the first clause of the  
function; subsequent clauses are ignored.</p>
 
  <p>An exception is thrown if <c>function_clauses(Node)</c>
  returns an empty list, or if the first element of that list is not
  a syntax tree <c>C</c> of type <c>clause</c> such that
  <c>clause_patterns(C)</c> is a nonempty list.
 </p>
<p><em>See also:</em> <seemfa marker="#clause/3">clause/3</seemfa>, <seemfa marker="#clause_patterns/1">clause_patterns/1</seemfa>, <seemfa marker="#function/2">function/2</seemfa>, <seemfa marker="#function_clauses/1">function_clauses/1</seemfa>.</p>
</desc></func>
<func>
<name since="">function_clauses(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; [<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]</name>
<fsummary>Returns the list of clause subtrees of a function node.</fsummary>

<desc><marker id="function_clauses-1"/>

<p>Returns the list of clause subtrees of a <c>function</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#function/2">function/2</seemfa>.</p>
</desc></func>
<func>
<name since="">function_name(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the name subtree of a function node.</fsummary>

<desc><marker id="function_name-1"/>

<p>Returns the name subtree of a <c>function</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#function/2">function/2</seemfa>.</p>
</desc></func>
<func>
<name since="">function_type(Type) -&gt; term()
</name>
<fsummary>Equivalent to function_type(any_arity, Type).
</fsummary>

<desc><marker id="function_type-1"/>
<p>Equivalent to <seemfa marker="#function_type/2">function_type(any_arity, Type)</seemfa>.</p>
</desc></func>
<func>
<name since="">function_type(Arguments::any_arity | [<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>], Return::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract function type.</fsummary>

<desc><marker id="function_type-2"/>

<p>Creates an abstract function type. If <c>Arguments</c> is
  <c>[T1, ..., Tn]</c>, then if it occurs within a function
  specification, the result represents
  "<c>(T1, ...Tn) -&gt; Return</c>"; otherwise
  it represents
  "<c>fun((T1, ...Tn) -&gt; Return)</c>".
  If <c>Arguments</c> is <c>any_arity</c>, it represents
  "<c>fun((...) -&gt; Return)</c>".</p>
 
  <p>Note that the <c>erl_parse</c> representation is identical for
  "<c>FunctionType</c>" and
  "<c>fun(FunctionType)</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#function_type_arguments/1">function_type_arguments/1</seemfa>, <seemfa marker="#function_type_return/1">function_type_return/1</seemfa>.</p>
</desc></func>
<func>
<name since="">function_type_arguments(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; any_arity | [<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]</name>
<fsummary>Returns the argument types subtrees of a function_type node.</fsummary>

<desc><marker id="function_type_arguments-1"/>

<p>Returns the argument types subtrees of a <c>function_type</c> node.
  If <c>Node</c> represents "<c>fun((...) -&gt; Return)</c>",
  <c>any_arity</c> is returned; otherwise, if <c>Node</c> represents
  "<c>(T1, ...Tn) -&gt; Return</c>" or
  "<c>fun((T1, ...Tn) -&gt; Return)</c>",
  <c>[T1, ..., Tn]</c> is returned.</p>
<p><em>See also:</em> <seemfa marker="#function_type/1">function_type/1</seemfa>, <seemfa marker="#function_type/2">function_type/2</seemfa>.</p>
</desc></func>
<func>
<name since="">function_type_return(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the return type subtrees of a function_type node.</fsummary>

<desc><marker id="function_type_return-1"/>

<p>Returns the return type subtrees of a <c>function_type</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#function_type/1">function_type/1</seemfa>, <seemfa marker="#function_type/2">function_type/2</seemfa>.</p>
</desc></func>
<func>
<name since="">generator(Pattern::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Body::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract generator.</fsummary>

<desc><marker id="generator-2"/>

<p>Creates an abstract generator. The result represents
  "<c>Pattern &lt;- Body</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#binary_comp/2">binary_comp/2</seemfa>, <seemfa marker="#generator_body/1">generator_body/1</seemfa>, <seemfa marker="#generator_pattern/1">generator_pattern/1</seemfa>, <seemfa marker="#list_comp/2">list_comp/2</seemfa>.</p>
</desc></func>
<func>
<name since="">generator_body(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the body subtree of a generator node.</fsummary>

<desc><marker id="generator_body-1"/>

<p>Returns the body subtree of a <c>generator</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#generator/2">generator/2</seemfa>.</p>
</desc></func>
<func>
<name since="">generator_pattern(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the pattern subtree of a generator node.</fsummary>

<desc><marker id="generator_pattern-1"/>

<p>Returns the pattern subtree of a <c>generator</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#generator/2">generator/2</seemfa>.</p>
</desc></func>
<func>
<name since="">get_ann(Tree::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; [term()]</name>
<fsummary>Returns the list of user annotations associated with a syntax
  tree node.</fsummary>

<desc><marker id="get_ann-1"/>

<p>Returns the list of user annotations associated with a syntax
  tree node. For a newly created node, this is the empty list. The
  annotations may be any terms.
 </p>
<p><em>See also:</em> <seemfa marker="#get_attrs/1">get_attrs/1</seemfa>, <seemfa marker="#set_ann/2">set_ann/2</seemfa>.</p>
</desc></func>
<func>
<name since="">get_attrs(Tree::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTreeAttributes">syntaxTreeAttributes()</seeerl></name>
<fsummary>Returns a representation of the attributes associated with a
  syntax tree node.</fsummary>

<desc><marker id="get_attrs-1"/>

<p>Returns a representation of the attributes associated with a
  syntax tree node. The attributes are all the extra information that
  can be attached to a node. Currently, this includes position
  information, source code comments, and user annotations. The result
  of this function cannot be inspected directly; only attached to
  another node (see <seemfa marker="#set_attrs/2">set_attrs/2</seemfa>).</p>
 
  <p>For accessing individual attributes, see <seemfa marker="#get_pos/1">get_pos/1</seemfa>,
  <seemfa marker="#get_ann/1">get_ann/1</seemfa>, <seemfa marker="#get_precomments/1">get_precomments/1</seemfa> and
  <seemfa marker="#get_postcomments/1">get_postcomments/1</seemfa>.
 </p>
<p><em>See also:</em> <seemfa marker="#get_ann/1">get_ann/1</seemfa>, <seemfa marker="#get_pos/1">get_pos/1</seemfa>, <seemfa marker="#get_postcomments/1">get_postcomments/1</seemfa>, <seemfa marker="#get_precomments/1">get_precomments/1</seemfa>, <seemfa marker="#set_attrs/2">set_attrs/2</seemfa>.</p>
</desc></func>
<func>
<name since="">get_pos(Tree::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-annotation_or_location">annotation_or_location()</seeerl></name>
<fsummary>Returns the annotation (see //stdlib/erl_anno)
  associated with Node.</fsummary>

<desc><marker id="get_pos-1"/>

<p>Returns the annotation (see <seeerl marker="stdlib:erl_anno">erl_anno(3)</seeerl>)
  associated with <c>Node</c>. By default, all new tree nodes have their
  associated position information set to the integer zero. Use <seemfa marker="stdlib:erl_anno#location/1">erl_anno:location/1</seemfa> or <seemfa marker="stdlib:erl_anno#line/1">erl_anno:line/1</seemfa>
  to get the position information.
 </p>
<p><em>See also:</em> <seemfa marker="#get_attrs/1">get_attrs/1</seemfa>, <seemfa marker="#set_pos/2">set_pos/2</seemfa>.</p>
</desc></func>
<func>
<name since="">get_postcomments(Tree::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; [<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]</name>
<fsummary>Returns the associated post-comments of a node.</fsummary>

<desc><marker id="get_postcomments-1"/>

<p>Returns the associated post-comments of a node. This is a
  possibly empty list of abstract comments, in top-down textual order.
  When the code is formatted, post-comments are typically displayed to
  the right of and/or below the node. For example:
  </p><pre>     {foo, X, Y}     % Post-comment of tuple</pre><p>
 
  If possible, the comment should be moved past any following
  separator characters on the same line, rather than placing the
  separators on the following line. E.g.:
  </p><pre>     foo([X | Xs], Y) -&gt;
         foo(Xs, bar(X));     % Post-comment of 'bar(X)' node
      ...</pre><p>
  (where the comment is moved past the rightmost "<c>)</c>" and
  the "<c>;</c>").
 </p>
<p><em>See also:</em> <seemfa marker="#comment/2">comment/2</seemfa>, <seemfa marker="#get_attrs/1">get_attrs/1</seemfa>, <seemfa marker="#get_precomments/1">get_precomments/1</seemfa>, <seemfa marker="#set_postcomments/2">set_postcomments/2</seemfa>.</p>
</desc></func>
<func>
<name since="">get_precomments(Tree::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; [<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]</name>
<fsummary>Returns the associated pre-comments of a node.</fsummary>

<desc><marker id="get_precomments-1"/>

<p>Returns the associated pre-comments of a node. This is a
  possibly empty list of abstract comments, in top-down textual order.
  When the code is formatted, pre-comments are typically displayed
  directly above the node. For example:
  </p><pre>     % Pre-comment of function
     foo(X) -&gt; {bar, X}.</pre><p>
 
  If possible, the comment should be moved before any preceding
  separator characters on the same line. E.g.:
  </p><pre>     foo([X | Xs]) -&gt;
         % Pre-comment of 'bar(X)' node
         [bar(X) | foo(Xs)];
     ...</pre><p>
  (where the comment is moved before the "<c>[</c>").
 </p>
<p><em>See also:</em> <seemfa marker="#comment/2">comment/2</seemfa>, <seemfa marker="#get_attrs/1">get_attrs/1</seemfa>, <seemfa marker="#get_postcomments/1">get_postcomments/1</seemfa>, <seemfa marker="#set_precomments/2">set_precomments/2</seemfa>.</p>
</desc></func>
<func>
<name since="">has_comments(Tree::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; boolean()</name>
<fsummary>Yields false if the node has no associated
  comments, and true otherwise.</fsummary>

<desc><marker id="has_comments-1"/>

<p>Yields <c>false</c> if the node has no associated
  comments, and <c>true</c> otherwise.</p>
 
  <p>Note: This is equivalent to <c>(get_precomments(Node) == [])
  and (get_postcomments(Node) == [])</c>, but potentially more
  efficient.
 </p>
<p><em>See also:</em> <seemfa marker="#get_postcomments/1">get_postcomments/1</seemfa>, <seemfa marker="#get_precomments/1">get_precomments/1</seemfa>, <seemfa marker="#remove_comments/1">remove_comments/1</seemfa>.</p>
</desc></func>
<func>
<name since="">if_expr(Clauses::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract if-expression.</fsummary>

<desc><marker id="if_expr-1"/>

<p>Creates an abstract if-expression. If <c>Clauses</c> is
  <c>[C1, ..., Cn]</c>, the result represents "<c>if
  C1; ...; Cn end</c>". More exactly, if each
  <c>Ci</c> represents "<c>() Gi -&gt;
  Bi</c>", then the result represents "<c>if
  G1 -&gt; B1; ...; Gn -&gt; Bn
  end</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#case_expr/2">case_expr/2</seemfa>, <seemfa marker="#clause/3">clause/3</seemfa>, <seemfa marker="#if_expr_clauses/1">if_expr_clauses/1</seemfa>.</p>
</desc></func>
<func>
<name since="">if_expr_clauses(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; [<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]</name>
<fsummary>Returns the list of clause subtrees of an if_expr node.</fsummary>

<desc><marker id="if_expr_clauses-1"/>

<p>Returns the list of clause subtrees of an <c>if_expr</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#if_expr/1">if_expr/1</seemfa>.</p>
</desc></func>
<func>
<name since="">implicit_fun(Name::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract "implicit fun" expression.</fsummary>

<desc><marker id="implicit_fun-1"/>

<p>Creates an abstract "implicit fun" expression. The result
  represents "<c>fun Name</c>". <c>Name</c> should
  represent either <c>F/A</c> or
  <c>M:F/A</c>
 </p>
<p><em>See also:</em> <seemfa marker="#arity_qualifier/2">arity_qualifier/2</seemfa>, <seemfa marker="#implicit_fun/2">implicit_fun/2</seemfa>, <seemfa marker="#implicit_fun/3">implicit_fun/3</seemfa>, <seemfa marker="#implicit_fun_name/1">implicit_fun_name/1</seemfa>, <seemfa marker="#module_qualifier/2">module_qualifier/2</seemfa>.</p>
</desc></func>
<func>
<name since="">implicit_fun(Name::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Arity::none | <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract "implicit fun" expression.</fsummary>

<desc><marker id="implicit_fun-2"/>

<p>Creates an abstract "implicit fun" expression. If
  <c>Arity</c> is <c>none</c>, this is equivalent to
  <c>implicit_fun(Name)</c>, otherwise it is equivalent to
  <c>implicit_fun(arity_qualifier(Name, Arity))</c>.</p>
 
  <p>(This is a utility function.)
 </p>
<p><em>See also:</em> <seemfa marker="#implicit_fun/1">implicit_fun/1</seemfa>, <seemfa marker="#implicit_fun/3">implicit_fun/3</seemfa>.</p>
</desc></func>
<func>
<name since="">implicit_fun(Module::none | <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Name::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Arity::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract module-qualified "implicit fun" expression.</fsummary>

<desc><marker id="implicit_fun-3"/>

<p>Creates an abstract module-qualified "implicit fun" expression.
  If <c>Module</c> is <c>none</c>, this is equivalent to
  <c>implicit_fun(Name, Arity)</c>, otherwise it is equivalent to
  <c>implicit_fun(module_qualifier(Module, arity_qualifier(Name,
  Arity))</c>.</p>
 
  <p>(This is a utility function.)
 </p>
<p><em>See also:</em> <seemfa marker="#implicit_fun/1">implicit_fun/1</seemfa>, <seemfa marker="#implicit_fun/2">implicit_fun/2</seemfa>.</p>
</desc></func>
<func>
<name since="">implicit_fun_name(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the name subtree of an implicit_fun node.</fsummary>

<desc><marker id="implicit_fun_name-1"/>

<p>Returns the name subtree of an <c>implicit_fun</c> node.</p>
 
  <p>Note: if <c>Node</c> represents "<c>fun
  N/A</c>" or "<c>fun
  M:N/A</c>", then the result is the
  subtree representing "<c>N/A</c>" or
  "<c>M:N/A</c>", respectively.
 </p>
<p><em>See also:</em> <seemfa marker="#arity_qualifier/2">arity_qualifier/2</seemfa>, <seemfa marker="#implicit_fun/1">implicit_fun/1</seemfa>, <seemfa marker="#module_qualifier/2">module_qualifier/2</seemfa>.</p>
</desc></func>
<func>
<name since="">infix_expr(Left::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Operator::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Right::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract infix operator expression.</fsummary>

<desc><marker id="infix_expr-3"/>

<p>Creates an abstract infix operator expression. The result
  represents "<c>Left Operator
  Right</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#infix_expr_left/1">infix_expr_left/1</seemfa>, <seemfa marker="#infix_expr_operator/1">infix_expr_operator/1</seemfa>, <seemfa marker="#infix_expr_right/1">infix_expr_right/1</seemfa>, <seemfa marker="#prefix_expr/2">prefix_expr/2</seemfa>.</p>
</desc></func>
<func>
<name since="">infix_expr_left(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the left argument subtree of an
  infix_expr node.</fsummary>

<desc><marker id="infix_expr_left-1"/>

<p>Returns the left argument subtree of an
  <c>infix_expr</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#infix_expr/3">infix_expr/3</seemfa>.</p>
</desc></func>
<func>
<name since="">infix_expr_operator(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the operator subtree of an infix_expr node.</fsummary>

<desc><marker id="infix_expr_operator-1"/>

<p>Returns the operator subtree of an <c>infix_expr</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#infix_expr/3">infix_expr/3</seemfa>.</p>
</desc></func>
<func>
<name since="">infix_expr_right(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the right argument subtree of an
  infix_expr node.</fsummary>

<desc><marker id="infix_expr_right-1"/>

<p>Returns the right argument subtree of an
  <c>infix_expr</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#infix_expr/3">infix_expr/3</seemfa>.</p>
</desc></func>
<func>
<name since="">integer(Value::integer()) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract integer literal.</fsummary>

<desc><marker id="integer-1"/>

<p>Creates an abstract integer literal. The lexical representation
  is the canonical decimal numeral of <c>Value</c>.
 </p>
<p><em>See also:</em> <seemfa marker="#integer_literal/1">integer_literal/1</seemfa>, <seemfa marker="#integer_value/1">integer_value/1</seemfa>, <seemfa marker="#is_integer/2">is_integer/2</seemfa>.</p>
</desc></func>
<func>
<name since="">integer_literal(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; string()</name>
<fsummary>Returns the numeral string represented by an integer node.</fsummary>

<desc><marker id="integer_literal-1"/>

<p>Returns the numeral string represented by an <c>integer</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#integer/1">integer/1</seemfa>.</p>
</desc></func>
<func>
<name since="">integer_range_type(Low::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, High::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract range type.</fsummary>

<desc><marker id="integer_range_type-2"/>

<p>Creates an abstract range type. The result represents
  "<c>Low .. High</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#integer_range_type_high/1">integer_range_type_high/1</seemfa>, <seemfa marker="#integer_range_type_low/1">integer_range_type_low/1</seemfa>.</p>
</desc></func>
<func>
<name since="">integer_range_type_high(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the high limit of an integer_range_type node.</fsummary>

<desc><marker id="integer_range_type_high-1"/>

<p>Returns the high limit of an <c>integer_range_type</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#integer_range_type/2">integer_range_type/2</seemfa>.</p>
</desc></func>
<func>
<name since="">integer_range_type_low(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the low limit of an integer_range_type node.</fsummary>

<desc><marker id="integer_range_type_low-1"/>

<p>Returns the low limit of an <c>integer_range_type</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#integer_range_type/2">integer_range_type/2</seemfa>.</p>
</desc></func>
<func>
<name since="">integer_value(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; integer()</name>
<fsummary>Returns the value represented by an integer node.</fsummary>

<desc><marker id="integer_value-1"/>

<p>Returns the value represented by an <c>integer</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#integer/1">integer/1</seemfa>.</p>
</desc></func>
<func>
<name since="">is_atom(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Value::atom()) -&gt; boolean()</name>
<fsummary>Returns true if Node has type
  atom and represents Value, otherwise false.</fsummary>

<desc><marker id="is_atom-2"/>

<p>Returns <c>true</c> if <c>Node</c> has type
  <c>atom</c> and represents <c>Value</c>, otherwise <c>false</c>.
 </p>
<p><em>See also:</em> <seemfa marker="#atom/1">atom/1</seemfa>.</p>
</desc></func>
<func>
<name since="">is_char(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Value::char()) -&gt; boolean()</name>
<fsummary>Returns true if Node has type
  char and represents Value, otherwise false.</fsummary>

<desc><marker id="is_char-2"/>

<p>Returns <c>true</c> if <c>Node</c> has type
  <c>char</c> and represents <c>Value</c>, otherwise <c>false</c>.
 </p>
<p><em>See also:</em> <seemfa marker="#char/1">char/1</seemfa>.</p>
</desc></func>
<func>
<name since="">is_form(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; boolean()</name>
<fsummary>Returns true if Node is a syntax tree
  representing a so-called "source code form", otherwise
  false.</fsummary>

<desc><marker id="is_form-1"/>

<p>Returns <c>true</c> if <c>Node</c> is a syntax tree
  representing a so-called "source code form", otherwise
  <c>false</c>. Forms are the Erlang source code units which,  
placed in sequence, constitute an Erlang program. Current form types  
are:</p>
 
  <p>
   
    <c>attribute</c>
    <c>comment</c>
    <c>error_marker</c>
    <c>eof_marker</c>
   <br/>
    <c>form_list</c>
    <c>function</c>
    <c>warning_marker</c>
    <c>text</c>
   <br/>
  
 </p>
<p><em>See also:</em> <seemfa marker="#attribute/2">attribute/2</seemfa>, <seemfa marker="#comment/2">comment/2</seemfa>, <seemfa marker="#eof_marker/0">eof_marker/0</seemfa>, <seemfa marker="#error_marker/1">error_marker/1</seemfa>, <seemfa marker="#form_list/1">form_list/1</seemfa>, <seemfa marker="#function/2">function/2</seemfa>, <seemfa marker="#type/1">type/1</seemfa>, <seemfa marker="#warning_marker/1">warning_marker/1</seemfa>.</p>
</desc></func>
<func>
<name since="">is_integer(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Value::integer()) -&gt; boolean()</name>
<fsummary>Returns true if Node has type
  integer and represents Value, otherwise false.</fsummary>

<desc><marker id="is_integer-2"/>

<p>Returns <c>true</c> if <c>Node</c> has type
  <c>integer</c> and represents <c>Value</c>, otherwise <c>false</c>.
 </p>
<p><em>See also:</em> <seemfa marker="#integer/1">integer/1</seemfa>.</p>
</desc></func>
<func>
<name since="">is_leaf(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; boolean()</name>
<fsummary>Returns true if Node is a leaf node,
  otherwise false.</fsummary>

<desc><marker id="is_leaf-1"/>

<p>Returns <c>true</c> if <c>Node</c> is a leaf node,
  otherwise <c>false</c>. The currently recognised leaf node  
types are:</p>
 
  <p>
   
    <c>atom</c>
    <c>char</c>
    <c>comment</c>
    <c>eof_marker</c>
    <c>error_marker</c>
   <br/>
    <c>float</c>
    <c>fun_type</c>
    <c>integer</c>
    <c>nil</c>
    <c>operator</c>
    <c>string</c>
   <br/>
    <c>text</c>
    <c>underscore</c>
    <c>variable</c>
    <c>warning_marker</c>
   <br/>
  </p>
 
  <p>A node of type <c>map_expr</c> is a leaf node if and only if it has no
  argument and no fields.
  A node of type <c>map_type</c> is a leaf node if and only if it has no
  fields (<c>any_size</c>).
  A node of type <c>tuple</c> is a leaf node if and only if its arity is zero.
  A node of type <c>tuple_type</c> is a leaf node if and only if it has no
  elements (<c>any_size</c>).</p>
 
  <p>Note: not all literals are leaf nodes, and vice versa. E.g.,
  tuples with nonzero arity and nonempty lists may be literals, but are
  not leaf nodes. Variables, on the other hand, are leaf nodes but not
  literals.
 </p>
<p><em>See also:</em> <seemfa marker="#is_literal/1">is_literal/1</seemfa>, <seemfa marker="#type/1">type/1</seemfa>.</p>
</desc></func>
<func>
<name since="">is_list_skeleton(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; boolean()</name>
<fsummary>Returns true if Node has type
  list or nil, otherwise false.</fsummary>

<desc><marker id="is_list_skeleton-1"/>

<p>Returns <c>true</c> if <c>Node</c> has type
  <c>list</c> or <c>nil</c>, otherwise <c>false</c>.
 </p>
<p><em>See also:</em> <seemfa marker="#list/2">list/2</seemfa>, <seemfa marker="#nil/0">nil/0</seemfa>.</p>
</desc></func>
<func>
<name since="">is_literal(T::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; boolean()</name>
<fsummary>Returns true if Node represents a
  literal term, otherwise false.</fsummary>

<desc><marker id="is_literal-1"/>

<p>Returns <c>true</c> if <c>Node</c> represents a
  literal term, otherwise <c>false</c>. This function returns
  <c>true</c> if and only if the value of
  <c>concrete(Node)</c> is defined.
 </p>
<p><em>See also:</em> <seemfa marker="#abstract/1">abstract/1</seemfa>, <seemfa marker="#concrete/1">concrete/1</seemfa>.</p>
</desc></func>
<func>
<name since="">is_proper_list(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; boolean()</name>
<fsummary>Returns true if Node represents a
  proper list, and false otherwise.</fsummary>

<desc><marker id="is_proper_list-1"/>

<p>Returns <c>true</c> if <c>Node</c> represents a
  proper list, and <c>false</c> otherwise. A proper list is a
  list skeleton either on the form "<c>[]</c>" or
  "<c>[E1, ..., En]</c>", or "<c>[... |
  Tail]</c>" where recursively <c>Tail</c> also  
represents a proper list.</p>
 
  <p>Note: Since <c>Node</c> is a syntax tree, the actual
  run-time values corresponding to its subtrees may often be partially
  or completely unknown. Thus, if <c>Node</c> represents e.g.
  "<c>[... | Ns]</c>" (where <c>Ns</c> is a variable), then
  the function will return <c>false</c>, because it is not known
  whether <c>Ns</c> will be bound to a list at run-time. If
  <c>Node</c> instead represents e.g. "<c>[1, 2, 3]</c>" or
  "<c>[A | []]</c>", then the function will return
  <c>true</c>.
 </p>
<p><em>See also:</em> <seemfa marker="#list/2">list/2</seemfa>.</p>
</desc></func>
<func>
<name since="">is_string(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Value::string()) -&gt; boolean()</name>
<fsummary>Returns true if Node has type
  string and represents Value, otherwise false.</fsummary>

<desc><marker id="is_string-2"/>

<p>Returns <c>true</c> if <c>Node</c> has type
  <c>string</c> and represents <c>Value</c>, otherwise <c>false</c>.
 </p>
<p><em>See also:</em> <seemfa marker="#string/1">string/1</seemfa>.</p>
</desc></func>
<func>
<name since="">is_tree(Tree::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; boolean()</name>
<fsummary>For special purposes only.</fsummary>

<desc><marker id="is_tree-1"/>

<p><em>For special purposes only</em>. Returns <c>true</c> if
  <c>Tree</c> is an abstract syntax tree and <c>false</c>  
otherwise.</p>
 
  <p><em>Note</em>: this function yields <c>false</c> for all
  "old-style" <c>erl_parse</c>-compatible "parse trees".
 </p>
<p><em>See also:</em> <seemfa marker="#tree/2">tree/2</seemfa>.</p>
</desc></func>
<func>
<name since="">join_comments(Source::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Target::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Appends the comments of Source to the current
  comments of Target.</fsummary>

<desc><marker id="join_comments-2"/>

<p>Appends the comments of <c>Source</c> to the current
  comments of <c>Target</c>.</p>
 
  <p>Note: This is equivalent to
  <c>add_postcomments(get_postcomments(Source),
  add_precomments(get_precomments(Source), Target))</c>, but
  potentially more efficient.
 </p>
<p><em>See also:</em> <seemfa marker="#add_postcomments/2">add_postcomments/2</seemfa>, <seemfa marker="#add_precomments/2">add_precomments/2</seemfa>, <seemfa marker="#comment/2">comment/2</seemfa>, <seemfa marker="#get_postcomments/1">get_postcomments/1</seemfa>, <seemfa marker="#get_precomments/1">get_precomments/1</seemfa>.</p>
</desc></func>
<func>
<name since="">list(List::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Equivalent to list(List, none).
</fsummary>

<desc><marker id="list-1"/>
<p>Equivalent to <seemfa marker="#list/2">list(List, none)</seemfa>.</p>
</desc></func>
<func>
<name since="">list(Elements::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>], Tail::none | <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Constructs an abstract list skeleton.</fsummary>

<desc><marker id="list-2"/>

<p>Constructs an abstract list skeleton. The result has type
  <c>list</c> or <c>nil</c>. If <c>List</c> is a
  nonempty list <c>[E1, ..., En]</c>, the result has type
  <c>list</c> and represents either "<c>[E1, ...,
  En]</c>", if <c>Tail</c> is <c>none</c>, or
  otherwise "<c>[E1, ..., En |
  Tail]</c>". If <c>List</c> is the empty list,
  <c>Tail</c> <em>must</em> be <c>none</c>, and in that
  case the result has type <c>nil</c> and represents
  "<c>[]</c>" (see <seemfa marker="#nil/0">nil/0</seemfa>).</p>
 
  <p>The difference between lists as semantic objects (built up of  
individual "cons" and "nil" terms) and the various syntactic forms  
for denoting lists may be bewildering at first. This module provides  
functions both for exact control of the syntactic representation as  
well as for the simple composition and deconstruction in terms of  
cons and head/tail operations.</p>
 
  <p>Note: in <c>list(Elements, none)</c>, the "nil" list
  terminator is implicit and has no associated information (see
  <seemfa marker="#get_attrs/1">get_attrs/1</seemfa>), while in the seemingly equivalent
  <c>list(Elements, Tail)</c> when <c>Tail</c> has type
  <c>nil</c>, the list terminator subtree <c>Tail</c> may
  have attached attributes such as position, comments, and annotations,
  which will be preserved in the result.
 </p>
<p><em>See also:</em> <seemfa marker="#compact_list/1">compact_list/1</seemfa>, <seemfa marker="#cons/2">cons/2</seemfa>, <seemfa marker="#get_attrs/1">get_attrs/1</seemfa>, <seemfa marker="#is_list_skeleton/1">is_list_skeleton/1</seemfa>, <seemfa marker="#is_proper_list/1">is_proper_list/1</seemfa>, <seemfa marker="#list/1">list/1</seemfa>, <seemfa marker="#list_elements/1">list_elements/1</seemfa>, <seemfa marker="#list_head/1">list_head/1</seemfa>, <seemfa marker="#list_length/1">list_length/1</seemfa>, <seemfa marker="#list_prefix/1">list_prefix/1</seemfa>, <seemfa marker="#list_suffix/1">list_suffix/1</seemfa>, <seemfa marker="#list_tail/1">list_tail/1</seemfa>, <seemfa marker="#nil/0">nil/0</seemfa>, <seemfa marker="#normalize_list/1">normalize_list/1</seemfa>.</p>
</desc></func>
<func>
<name since="">list_comp(Template::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Body::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract list comprehension.</fsummary>

<desc><marker id="list_comp-2"/>

<p>Creates an abstract list comprehension. If <c>Body</c> is
  <c>[E1, ..., En]</c>, the result represents
  "<c>[Template || E1, ..., En]</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#generator/2">generator/2</seemfa>, <seemfa marker="#list_comp_body/1">list_comp_body/1</seemfa>, <seemfa marker="#list_comp_template/1">list_comp_template/1</seemfa>.</p>
</desc></func>
<func>
<name since="">list_comp_body(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; [<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]</name>
<fsummary>Returns the list of body subtrees of a list_comp node.</fsummary>

<desc><marker id="list_comp_body-1"/>

<p>Returns the list of body subtrees of a <c>list_comp</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#list_comp/2">list_comp/2</seemfa>.</p>
</desc></func>
<func>
<name since="">list_comp_template(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the template subtree of a list_comp node.</fsummary>

<desc><marker id="list_comp_template-1"/>

<p>Returns the template subtree of a <c>list_comp</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#list_comp/2">list_comp/2</seemfa>.</p>
</desc></func>
<func>
<name since="">list_elements(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; [<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]</name>
<fsummary>Returns the list of element subtrees of a list skeleton.</fsummary>

<desc><marker id="list_elements-1"/>

<p>Returns the list of element subtrees of a list skeleton.
  <c>Node</c> must represent a proper list. E.g., if
  <c>Node</c> represents "<c>[X1, X2 |
  [X3, X4 | []]</c>", then
  <c>list_elements(Node)</c> yields the list <c>[X1, X2, X3, X4]</c>.
 </p>
<p><em>See also:</em> <seemfa marker="#is_proper_list/1">is_proper_list/1</seemfa>, <seemfa marker="#list/2">list/2</seemfa>.</p>
</desc></func>
<func>
<name since="">list_head(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the head element subtree of a list node.</fsummary>

<desc><marker id="list_head-1"/>

<p>Returns the head element subtree of a <c>list</c> node. If
  <c>Node</c> represents "<c>[Head ...]</c>", the
  result will represent "<c>Head</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#cons/2">cons/2</seemfa>, <seemfa marker="#list/2">list/2</seemfa>, <seemfa marker="#list_tail/1">list_tail/1</seemfa>.</p>
</desc></func>
<func>
<name since="">list_length(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; non_neg_integer()</name>
<fsummary>Returns the number of element subtrees of a list skeleton.</fsummary>

<desc><marker id="list_length-1"/>

<p>Returns the number of element subtrees of a list skeleton.
  <c>Node</c> must represent a proper list. E.g., if
  <c>Node</c> represents "<c>[X1 | [X2, X3 | [X4, X5,
  X6]]]</c>", then <c>list_length(Node)</c> returns the  
integer 6.</p>
 
  <p>Note: this is equivalent to
  <c>length(list_elements(Node))</c>, but potentially more
  efficient.
 </p>
<p><em>See also:</em> <seemfa marker="#is_proper_list/1">is_proper_list/1</seemfa>, <seemfa marker="#list/2">list/2</seemfa>, <seemfa marker="#list_elements/1">list_elements/1</seemfa>.</p>
</desc></func>
<func>
<name since="">list_prefix(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; [<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]</name>
<fsummary>Returns the prefix element subtrees of a list node.</fsummary>

<desc><marker id="list_prefix-1"/>

<p>Returns the prefix element subtrees of a <c>list</c> node.
  If <c>Node</c> represents "<c>[E1, ...,
  En]</c>" or "<c>[E1, ..., En |
  Tail]</c>", the returned value is <c>[E1, ...,
  En]</c>.
 </p>
<p><em>See also:</em> <seemfa marker="#list/2">list/2</seemfa>.</p>
</desc></func>
<func>
<name since="">list_suffix(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; none | <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the suffix subtree of a list node, if one
  exists.</fsummary>

<desc><marker id="list_suffix-1"/>

<p>Returns the suffix subtree of a <c>list</c> node, if one
  exists. If <c>Node</c> represents "<c>[E1, ...,
  En | Tail]</c>", the returned value is
  <c>Tail</c>, otherwise, i.e., if <c>Node</c> represents
  "<c>[E1, ..., En]</c>", <c>none</c> is  
returned.</p>
 
  <p>Note that even if this function returns some <c>Tail</c>
  that is not <c>none</c>, the type of <c>Tail</c> can be
  <c>nil</c>, if the tail has been given explicitly, and the list
  skeleton has not been compacted (see <seemfa marker="#compact_list/1">compact_list/1</seemfa>).
 </p>
<p><em>See also:</em> <seemfa marker="#compact_list/1">compact_list/1</seemfa>, <seemfa marker="#list/2">list/2</seemfa>, <seemfa marker="#nil/0">nil/0</seemfa>.</p>
</desc></func>
<func>
<name since="">list_tail(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the tail of a list node.</fsummary>

<desc><marker id="list_tail-1"/>

<p>Returns the tail of a <c>list</c> node. If
  <c>Node</c> represents a single-element list
  "<c>[E]</c>", then the result has type
  <c>nil</c>, representing "<c>[]</c>". If
  <c>Node</c> represents "<c>[E1, E2
  ...]</c>", the result will represent "<c>[E2
  ...]</c>", and if <c>Node</c> represents
  "<c>[Head | Tail]</c>", the result will
  represent "<c>Tail</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#cons/2">cons/2</seemfa>, <seemfa marker="#list/2">list/2</seemfa>, <seemfa marker="#list_head/1">list_head/1</seemfa>.</p>
</desc></func>
<func>
<name since="">macro(Name::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Equivalent to macro(Name, none).
</fsummary>

<desc><marker id="macro-1"/>
<p>Equivalent to <seemfa marker="#macro/2">macro(Name, none)</seemfa>.</p>
</desc></func>
<func>
<name since="">macro(Name::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Arguments::none | [<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract macro application.</fsummary>

<desc><marker id="macro-2"/>

<p>Creates an abstract macro application. If <c>Arguments</c>
  is <c>none</c>, the result represents
  "<c>?Name</c>", otherwise, if <c>Arguments</c>
  is <c>[A1, ..., An]</c>, the result represents
  "<c>?Name(A1, ..., An)</c>".</p>
 
  <p>Notes: if <c>Arguments</c> is the empty list, the result
  will thus represent "<c>?Name()</c>", including a pair  
of matching parentheses.</p>
 
  <p>The only syntactical limitation imposed by the preprocessor on the
  arguments to a macro application (viewed as sequences of tokens) is
  that they must be balanced with respect to parentheses, brackets,
  <c>begin ... end</c>, <c>case ... end</c>, etc. The
  <c>text</c> node type can be used to represent arguments which
  are not regular Erlang constructs.
 </p>
<p><em>See also:</em> <seemfa marker="#macro/1">macro/1</seemfa>, <seemfa marker="#macro_arguments/1">macro_arguments/1</seemfa>, <seemfa marker="#macro_name/1">macro_name/1</seemfa>, <seemfa marker="#text/1">text/1</seemfa>.</p>
</desc></func>
<func>
<name since="">macro_arguments(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; none | [<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]</name>
<fsummary>Returns the list of argument subtrees of a macro
  node, if any.</fsummary>

<desc><marker id="macro_arguments-1"/>

<p>Returns the list of argument subtrees of a <c>macro</c>
  node, if any. If <c>Node</c> represents
  "<c>?Name</c>", <c>none</c> is returned.
  Otherwise, if <c>Node</c> represents
  "<c>?Name(A1, ..., An)</c>",
  <c>[A1, ..., An]</c> is returned.
 </p>
<p><em>See also:</em> <seemfa marker="#macro/2">macro/2</seemfa>.</p>
</desc></func>
<func>
<name since="">macro_name(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the name subtree of a macro node.</fsummary>

<desc><marker id="macro_name-1"/>

<p>Returns the name subtree of a <c>macro</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#macro/2">macro/2</seemfa>.</p>
</desc></func>
<func>
<name since="">make_tree(X1::atom(), X2::[[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]]) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates a syntax tree with the given type and subtrees.</fsummary>

<desc><marker id="make_tree-2"/>

<p>Creates a syntax tree with the given type and subtrees.
  <c>Type</c> must be a node type name (see <seemfa marker="#type/1">type/1</seemfa>)
  that does not denote a leaf node type (see <seemfa marker="#is_leaf/1">is_leaf/1</seemfa>).
  <c>Groups</c> must be a <em>nonempty</em> list of groups of
  syntax trees, representing the subtrees of a node of the given type,
  in left-to-right order as they would occur in the printed program
  text, grouped by category as done by <seemfa marker="#subtrees/1">subtrees/1</seemfa>.</p>
 
  <p>The result of <c>copy_attrs(Node, make_tree(type(Node),
  subtrees(Node)))</c> (see <seemfa marker="#update_tree/2">update_tree/2</seemfa>) represents
  the same source code text as the original <c>Node</c>, assuming
  that <c>subtrees(Node)</c> yields a nonempty list. However, it
  does not necessarily have the same data representation as
  <c>Node</c>.
 </p>
<p><em>See also:</em> <seemfa marker="#copy_attrs/2">copy_attrs/2</seemfa>, <seemfa marker="#is_leaf/1">is_leaf/1</seemfa>, <seemfa marker="#subtrees/1">subtrees/1</seemfa>, <seemfa marker="#type/1">type/1</seemfa>, <seemfa marker="#update_tree/2">update_tree/2</seemfa>.</p>
</desc></func>
<func>
<name since="">map_expr(Fields::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Equivalent to map_expr(none, Fields).
</fsummary>

<desc><marker id="map_expr-1"/>
<p>Equivalent to <seemfa marker="#map_expr/2">map_expr(none, Fields)</seemfa>.</p>
</desc></func>
<func>
<name since="">map_expr(Argument::none | <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Fields::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract map expression.</fsummary>

<desc><marker id="map_expr-2"/>

<p>Creates an abstract map expression. If <c>Fields</c> is
  <c>[F1, ..., Fn]</c>, then if <c>Argument</c> is <c>none</c>, the result represents
  "<c>#{F1, ..., Fn}</c>",
  otherwise it represents
  "<c>Argument#{F1, ..., Fn}</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#map_expr/1">map_expr/1</seemfa>, <seemfa marker="#map_expr_argument/1">map_expr_argument/1</seemfa>, <seemfa marker="#map_expr_fields/1">map_expr_fields/1</seemfa>, <seemfa marker="#map_field_assoc/2">map_field_assoc/2</seemfa>, <seemfa marker="#map_field_exact/2">map_field_exact/2</seemfa>.</p>
</desc></func>
<func>
<name since="">map_expr_argument(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; none | <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the argument subtree of a map_expr node, if any.</fsummary>

<desc><marker id="map_expr_argument-1"/>

<p>Returns the argument subtree of a <c>map_expr</c> node, if any. If <c>Node</c>
  represents "<c>#{...}</c>", <c>none</c> is returned.
  Otherwise, if <c>Node</c> represents "<c>Argument#{...}</c>",
  <c>Argument</c> is returned.
 </p>
<p><em>See also:</em> <seemfa marker="#map_expr/2">map_expr/2</seemfa>.</p>
</desc></func>
<func>
<name since="">map_expr_fields(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; [<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]</name>
<fsummary>Returns the list of field subtrees of a map_expr node.</fsummary>

<desc><marker id="map_expr_fields-1"/>

<p>Returns the list of field subtrees of a <c>map_expr</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#map_expr/2">map_expr/2</seemfa>.</p>
</desc></func>
<func>
<name since="">map_field_assoc(Name::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Value::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract map assoc field.</fsummary>

<desc><marker id="map_field_assoc-2"/>

<p>Creates an abstract map assoc field. The result represents
  "<c>Name =&gt; Value</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#map_expr/2">map_expr/2</seemfa>, <seemfa marker="#map_field_assoc_name/1">map_field_assoc_name/1</seemfa>, <seemfa marker="#map_field_assoc_value/1">map_field_assoc_value/1</seemfa>.</p>
</desc></func>
<func>
<name since="">map_field_assoc_name(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the name subtree of a map_field_assoc node.</fsummary>

<desc><marker id="map_field_assoc_name-1"/>

<p>Returns the name subtree of a <c>map_field_assoc</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#map_field_assoc/2">map_field_assoc/2</seemfa>.</p>
</desc></func>
<func>
<name since="">map_field_assoc_value(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the value subtree of a map_field_assoc node.</fsummary>

<desc><marker id="map_field_assoc_value-1"/>

<p>Returns the value subtree of a <c>map_field_assoc</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#map_field_assoc/2">map_field_assoc/2</seemfa>.</p>
</desc></func>
<func>
<name since="">map_field_exact(Name::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Value::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract map exact field.</fsummary>

<desc><marker id="map_field_exact-2"/>

<p>Creates an abstract map exact field. The result represents
  "<c>Name := Value</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#map_expr/2">map_expr/2</seemfa>, <seemfa marker="#map_field_exact_name/1">map_field_exact_name/1</seemfa>, <seemfa marker="#map_field_exact_value/1">map_field_exact_value/1</seemfa>.</p>
</desc></func>
<func>
<name since="">map_field_exact_name(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the name subtree of a map_field_exact node.</fsummary>

<desc><marker id="map_field_exact_name-1"/>

<p>Returns the name subtree of a <c>map_field_exact</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#map_field_exact/2">map_field_exact/2</seemfa>.</p>
</desc></func>
<func>
<name since="">map_field_exact_value(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the value subtree of a map_field_exact node.</fsummary>

<desc><marker id="map_field_exact_value-1"/>

<p>Returns the value subtree of a <c>map_field_exact</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#map_field_exact/2">map_field_exact/2</seemfa>.</p>
</desc></func>
<func>
<name since="">map_type() -&gt; term()
</name>
<fsummary>Equivalent to map_type(any_size).
</fsummary>

<desc><marker id="map_type-0"/>
<p>Equivalent to <seemfa marker="#map_type/1">map_type(any_size)</seemfa>.</p>
</desc></func>
<func>
<name since="">map_type(Fields::any_size | [<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract type map.</fsummary>

<desc><marker id="map_type-1"/>

<p>Creates an abstract type map. If <c>Fields</c> is
  <c>[F1, ..., Fn]</c>, the result represents
  "<c>#{F1, ..., Fn}</c>";
  otherwise, if <c>Fields</c> is <c>any_size</c>, it represents
  "<c>map()</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#map_type_fields/1">map_type_fields/1</seemfa>.</p>
</desc></func>
<func>
<name since="">map_type_assoc(Name::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Value::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract map type assoc field.</fsummary>

<desc><marker id="map_type_assoc-2"/>

<p>Creates an abstract map type assoc field. The result represents
  "<c>Name =&gt; Value</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#map_type/1">map_type/1</seemfa>, <seemfa marker="#map_type_assoc_name/1">map_type_assoc_name/1</seemfa>, <seemfa marker="#map_type_assoc_value/1">map_type_assoc_value/1</seemfa>.</p>
</desc></func>
<func>
<name since="">map_type_assoc_name(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the name subtree of a map_type_assoc node.</fsummary>

<desc><marker id="map_type_assoc_name-1"/>

<p>Returns the name subtree of a <c>map_type_assoc</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#map_type_assoc/2">map_type_assoc/2</seemfa>.</p>
</desc></func>
<func>
<name since="">map_type_assoc_value(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the value subtree of a map_type_assoc node.</fsummary>

<desc><marker id="map_type_assoc_value-1"/>

<p>Returns the value subtree of a <c>map_type_assoc</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#map_type_assoc/2">map_type_assoc/2</seemfa>.</p>
</desc></func>
<func>
<name since="">map_type_exact(Name::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Value::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract map type exact field.</fsummary>

<desc><marker id="map_type_exact-2"/>

<p>Creates an abstract map type exact field. The result represents
  "<c>Name := Value</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#map_type/1">map_type/1</seemfa>, <seemfa marker="#map_type_exact_name/1">map_type_exact_name/1</seemfa>, <seemfa marker="#map_type_exact_value/1">map_type_exact_value/1</seemfa>.</p>
</desc></func>
<func>
<name since="">map_type_exact_name(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the name subtree of a map_type_exact node.</fsummary>

<desc><marker id="map_type_exact_name-1"/>

<p>Returns the name subtree of a <c>map_type_exact</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#map_type_exact/2">map_type_exact/2</seemfa>.</p>
</desc></func>
<func>
<name since="">map_type_exact_value(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the value subtree of a map_type_exact node.</fsummary>

<desc><marker id="map_type_exact_value-1"/>

<p>Returns the value subtree of a <c>map_type_exact</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#map_type_exact/2">map_type_exact/2</seemfa>.</p>
</desc></func>
<func>
<name since="">map_type_fields(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; any_size | [<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]</name>
<fsummary>Returns the list of field subtrees of a map_type node.</fsummary>

<desc><marker id="map_type_fields-1"/>

<p>Returns the list of field subtrees of a <c>map_type</c> node.
  If <c>Node</c> represents "<c>map()</c>", <c>any_size</c> is returned;
  otherwise, if <c>Node</c> represents
  "<c>#{F1, ..., Fn}</c>",
  <c>[F1, ..., Fn]</c> is returned.
 </p>
<p><em>See also:</em> <seemfa marker="#map_type/0">map_type/0</seemfa>, <seemfa marker="#map_type/1">map_type/1</seemfa>.</p>
</desc></func>
<func>
<name since="">match_expr(Pattern::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Body::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract match-expression.</fsummary>

<desc><marker id="match_expr-2"/>

<p>Creates an abstract match-expression. The result represents
  "<c>Pattern = Body</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#match_expr_body/1">match_expr_body/1</seemfa>, <seemfa marker="#match_expr_pattern/1">match_expr_pattern/1</seemfa>.</p>
</desc></func>
<func>
<name since="">match_expr_body(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the body subtree of a match_expr node.</fsummary>

<desc><marker id="match_expr_body-1"/>

<p>Returns the body subtree of a <c>match_expr</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#match_expr/2">match_expr/2</seemfa>.</p>
</desc></func>
<func>
<name since="">match_expr_pattern(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the pattern subtree of a match_expr node.</fsummary>

<desc><marker id="match_expr_pattern-1"/>

<p>Returns the pattern subtree of a <c>match_expr</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#match_expr/2">match_expr/2</seemfa>.</p>
</desc></func>
<func>
<name since="">maybe_expr(Body::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Equivalent to maybe_expr(Body, none).
</fsummary>

<desc><marker id="maybe_expr-1"/>
<p>Equivalent to <seemfa marker="#maybe_expr/2">maybe_expr(Body, none)</seemfa>.</p>
</desc></func>
<func>
<name since="">maybe_expr(Body::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>], OptionalElse::none | <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract maybe-expression.</fsummary>

<desc><marker id="maybe_expr-2"/>

<p>Creates an abstract maybe-expression. If <c>Body</c> is <c>[B1, ...,
  Bn]</c>, and <c>OptionalElse</c> is <c>none</c>, the result represents
  "<c>maybe B1, ..., Bn end</c>".  If <c>Body</c>
  is <c>[B1, ..., Bn]</c>, and <c>OptionalElse</c> reprsents an <c>else_expr</c> node
  with clauses <c>[C1, ..., Cn]</c>, the result represents "<c>maybe
  B1, ..., Bn else C1; ..., Cn
  end</c>".</p>
 
 	<p>See <c>clause</c> for documentation on <c>erl_parse</c> clauses.
 </p>
<p><em>See also:</em> <seemfa marker="#maybe_expr_body/1">maybe_expr_body/1</seemfa>, <seemfa marker="#maybe_expr_else/1">maybe_expr_else/1</seemfa>.</p>
</desc></func>
<func>
<name since="">maybe_expr_body(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; [<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]</name>
<fsummary>Returns the list of body subtrees of a maybe_expr node.</fsummary>

<desc><marker id="maybe_expr_body-1"/>

<p>Returns the list of body subtrees of a <c>maybe_expr</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#maybe_expr/2">maybe_expr/2</seemfa>.</p>
</desc></func>
<func>
<name since="">maybe_expr_else(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; none | <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the else subtree of a maybe_expr node.</fsummary>

<desc><marker id="maybe_expr_else-1"/>

<p>Returns the else subtree of a <c>maybe_expr</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#maybe_expr/2">maybe_expr/2</seemfa>.</p>
</desc></func>
<func>
<name since="">maybe_match_expr(Pattern::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Body::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract maybe-expression, as used in maybe
  blocks.</fsummary>

<desc><marker id="maybe_match_expr-2"/>

<p>Creates an abstract maybe-expression, as used in <c>maybe</c>
  blocks. The result represents
  "<c>Pattern ?= Body</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#maybe_expr/2">maybe_expr/2</seemfa>, <seemfa marker="#maybe_match_expr_body/1">maybe_match_expr_body/1</seemfa>, <seemfa marker="#maybe_match_expr_pattern/1">maybe_match_expr_pattern/1</seemfa>.</p>
</desc></func>
<func>
<name since="">maybe_match_expr_body(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the body subtree of a maybe_expr node.</fsummary>

<desc><marker id="maybe_match_expr_body-1"/>

<p>Returns the body subtree of a <c>maybe_expr</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#maybe_match_expr/2">maybe_match_expr/2</seemfa>.</p>
</desc></func>
<func>
<name since="">maybe_match_expr_pattern(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the pattern subtree of a maybe_expr node.</fsummary>

<desc><marker id="maybe_match_expr_pattern-1"/>

<p>Returns the pattern subtree of a <c>maybe_expr</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#maybe_match_expr/2">maybe_match_expr/2</seemfa>.</p>
</desc></func>
<func>
<name since="">meta(T::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates a meta-representation of a syntax tree.</fsummary>

<desc><marker id="meta-1"/>

<p>Creates a meta-representation of a syntax tree. The result
  represents an Erlang expression "<c>MetaTree</c>"
  which, if evaluated, will yield a new syntax tree representing the
  same source code text as <c>Tree</c> (although the actual data
  representation may be different). The expression represented by
  <c>MetaTree</c> is <em>implementation independent</em> with
  regard to the data structures used by the abstract syntax tree
  implementation. Comments attached to nodes of <c>Tree</c> will  
be preserved, but other attributes are lost.</p>
 
  <p>Any node in <c>Tree</c> whose node type is
  <c>variable</c> (see <seemfa marker="#type/1">type/1</seemfa>), and whose list of
  annotations (see <seemfa marker="#get_ann/1">get_ann/1</seemfa>) contains the atom
  <c>meta_var</c>, will remain unchanged in the resulting tree,
  except that exactly one occurrence of <c>meta_var</c> is  
removed from its annotation list.</p>
 
  <p>The main use of the function <c>meta/1</c> is to transform a
  data structure <c>Tree</c>, which represents a piece of program
  code, into a form that is <em>representation independent when
  printed</em>. E.g., suppose <c>Tree</c> represents a variable
  named "V". Then (assuming a function <c>print/1</c> for
  printing syntax trees), evaluating <c>print(abstract(Tree))</c>
  - simply using <seemfa marker="#abstract/1">abstract/1</seemfa> to map the actual data
  structure onto a syntax tree representation - would output a string
  that might look something like "<c>{tree, variable, ..., "V",
  ...}</c>", which is obviously dependent on the implementation of
  the abstract syntax trees. This could e.g. be useful for caching a
  syntax tree in a file. However, in some situations like in a program
  generator generator (with two "generator"), it may be unacceptable.
  Using <c>print(meta(Tree))</c> instead would output a
  <em>representation independent</em> syntax tree generating
  expression; in the above case, something like
  "<c>erl_syntax:variable("V")</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#abstract/1">abstract/1</seemfa>, <seemfa marker="#get_ann/1">get_ann/1</seemfa>, <seemfa marker="#type/1">type/1</seemfa>.</p>
</desc></func>
<func>
<name since="">module_qualifier(Module::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Body::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract module qualifier.</fsummary>

<desc><marker id="module_qualifier-2"/>

<p>Creates an abstract module qualifier. The result represents
  "<c>Module:Body</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#module_qualifier_argument/1">module_qualifier_argument/1</seemfa>, <seemfa marker="#module_qualifier_body/1">module_qualifier_body/1</seemfa>.</p>
</desc></func>
<func>
<name since="">module_qualifier_argument(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the argument (the module) subtree of a
  module_qualifier node.</fsummary>

<desc><marker id="module_qualifier_argument-1"/>

<p>Returns the argument (the module) subtree of a
  <c>module_qualifier</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#module_qualifier/2">module_qualifier/2</seemfa>.</p>
</desc></func>
<func>
<name since="">module_qualifier_body(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the body subtree of a module_qualifier node.</fsummary>

<desc><marker id="module_qualifier_body-1"/>

<p>Returns the body subtree of a <c>module_qualifier</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#module_qualifier/2">module_qualifier/2</seemfa>.</p>
</desc></func>
<func>
<name since="">named_fun_expr(Name::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Clauses::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract named fun-expression.</fsummary>

<desc><marker id="named_fun_expr-2"/>

<p>Creates an abstract named fun-expression. If <c>Clauses</c> is
  <c>[C1, ..., Cn]</c>, the result represents "<c>fun
  Name C1; ...; Name Cn end</c>".
  More exactly, if each <c>Ci</c> represents
  "<c>(Pi1, ..., Pim) Gi -&gt; Bi</c>",
  then the result represents
  "<c>fun Name(P11, ..., P1m) G1 -&gt;
  B1; ...; Name(Pn1, ..., Pnm)
  Gn -&gt; Bn end</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#named_fun_expr_arity/1">named_fun_expr_arity/1</seemfa>, <seemfa marker="#named_fun_expr_clauses/1">named_fun_expr_clauses/1</seemfa>, <seemfa marker="#named_fun_expr_name/1">named_fun_expr_name/1</seemfa>.</p>
</desc></func>
<func>
<name since="">named_fun_expr_arity(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; arity()</name>
<fsummary>Returns the arity of a named_fun_expr node.</fsummary>

<desc><marker id="named_fun_expr_arity-1"/>

<p>Returns the arity of a <c>named_fun_expr</c> node. The result is  
the number of parameter patterns in the first clause of the  
named fun-expression; subsequent clauses are ignored.</p>
 
  <p>An exception is thrown if <c>named_fun_expr_clauses(Node)</c>
  returns an empty list, or if the first element of that list is not a
  syntax tree <c>C</c> of type <c>clause</c> such that
  <c>clause_patterns(C)</c> is a nonempty list.
 </p>
<p><em>See also:</em> <seemfa marker="#clause/3">clause/3</seemfa>, <seemfa marker="#clause_patterns/1">clause_patterns/1</seemfa>, <seemfa marker="#named_fun_expr/2">named_fun_expr/2</seemfa>, <seemfa marker="#named_fun_expr_clauses/1">named_fun_expr_clauses/1</seemfa>.</p>
</desc></func>
<func>
<name since="">named_fun_expr_clauses(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; [<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]</name>
<fsummary>Returns the list of clause subtrees of a named_fun_expr node.</fsummary>

<desc><marker id="named_fun_expr_clauses-1"/>

<p>Returns the list of clause subtrees of a <c>named_fun_expr</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#named_fun_expr/2">named_fun_expr/2</seemfa>.</p>
</desc></func>
<func>
<name since="">named_fun_expr_name(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the name subtree of a named_fun_expr node.</fsummary>

<desc><marker id="named_fun_expr_name-1"/>

<p>Returns the name subtree of a <c>named_fun_expr</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#named_fun_expr/2">named_fun_expr/2</seemfa>.</p>
</desc></func>
<func>
<name since="">nil() -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract empty list.</fsummary>

<desc><marker id="nil-0"/>

<p>Creates an abstract empty list. The result represents
  "<c>[]</c>". The empty list is traditionally called "nil".
 </p>
<p><em>See also:</em> <seemfa marker="#is_list_skeleton/1">is_list_skeleton/1</seemfa>, <seemfa marker="#list/2">list/2</seemfa>.</p>
</desc></func>
<func>
<name since="">normalize_list(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Expands an abstract list skeleton to its most explicit form.</fsummary>

<desc><marker id="normalize_list-1"/>

<p>Expands an abstract list skeleton to its most explicit form. If
  <c>Node</c> represents "<c>[E1, ..., En |
  Tail]</c>", the result represents "<c>[E1 |
  ... [En | Tail1] ... ]</c>", where
  <c>Tail1</c> is the result of
  <c>normalize_list(Tail)</c>. If <c>Node</c> represents
  "<c>[E1, ..., En]</c>", the result simply
  represents "<c>[E1 | ... [En | []] ...
  ]</c>". If <c>Node</c> does not represent a list skeleton,
  <c>Node</c> itself is returned.
 </p>
<p><em>See also:</em> <seemfa marker="#compact_list/1">compact_list/1</seemfa>, <seemfa marker="#list/2">list/2</seemfa>.</p>
</desc></func>
<func>
<name since="">operator(Name::atom() | string()) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract operator.</fsummary>

<desc><marker id="operator-1"/>

<p>Creates an abstract operator. The name of the operator is the
  character sequence represented by <c>Name</c>. This is
  analogous to the print name of an atom, but an operator is never
  written within single-quotes; e.g., the result of
  <c>operator('++')</c> represents "<c>++</c>" rather
  than "<c>'++'</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#atom/1">atom/1</seemfa>, <seemfa marker="#operator_literal/1">operator_literal/1</seemfa>, <seemfa marker="#operator_name/1">operator_name/1</seemfa>.</p>
</desc></func>
<func>
<name since="">operator_literal(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; string()</name>
<fsummary>Returns the literal string represented by an
  operator node.</fsummary>

<desc><marker id="operator_literal-1"/>

<p>Returns the literal string represented by an
  <c>operator</c> node. This is simply the operator name as a string.
 </p>
<p><em>See also:</em> <seemfa marker="#operator/1">operator/1</seemfa>.</p>
</desc></func>
<func>
<name since="">operator_name(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; atom()</name>
<fsummary>Returns the name of an operator node.</fsummary>

<desc><marker id="operator_name-1"/>

<p>Returns the name of an <c>operator</c> node. Note that
  the name is returned as an atom.
 </p>
<p><em>See also:</em> <seemfa marker="#operator/1">operator/1</seemfa>.</p>
</desc></func>
<func>
<name since="">parentheses(Expr::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract parenthesised expression.</fsummary>

<desc><marker id="parentheses-1"/>

<p>Creates an abstract parenthesised expression. The result
  represents "<c>(Body)</c>", independently of the
  context.
 </p>
<p><em>See also:</em> <seemfa marker="#parentheses_body/1">parentheses_body/1</seemfa>.</p>
</desc></func>
<func>
<name since="">parentheses_body(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the body subtree of a parentheses node.</fsummary>

<desc><marker id="parentheses_body-1"/>

<p>Returns the body subtree of a <c>parentheses</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#parentheses/1">parentheses/1</seemfa>.</p>
</desc></func>
<func>
<name since="">prefix_expr(Operator::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Argument::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract prefix operator expression.</fsummary>

<desc><marker id="prefix_expr-2"/>

<p>Creates an abstract prefix operator expression. The result
  represents "<c>Operator Argument</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#infix_expr/3">infix_expr/3</seemfa>, <seemfa marker="#prefix_expr_argument/1">prefix_expr_argument/1</seemfa>, <seemfa marker="#prefix_expr_operator/1">prefix_expr_operator/1</seemfa>.</p>
</desc></func>
<func>
<name since="">prefix_expr_argument(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the argument subtree of a prefix_expr node.</fsummary>

<desc><marker id="prefix_expr_argument-1"/>

<p>Returns the argument subtree of a <c>prefix_expr</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#prefix_expr/2">prefix_expr/2</seemfa>.</p>
</desc></func>
<func>
<name since="">prefix_expr_operator(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the operator subtree of a prefix_expr node.</fsummary>

<desc><marker id="prefix_expr_operator-1"/>

<p>Returns the operator subtree of a <c>prefix_expr</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#prefix_expr/2">prefix_expr/2</seemfa>.</p>
</desc></func>
<func>
<name since="">receive_expr(Clauses::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Equivalent to receive_expr(Clauses, none, []).
</fsummary>

<desc><marker id="receive_expr-1"/>
<p>Equivalent to <seemfa marker="#receive_expr/3">receive_expr(Clauses, none, [])</seemfa>.</p>
</desc></func>
<func>
<name since="">receive_expr(Clauses::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>], Timeout::none | <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Action::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract receive-expression.</fsummary>

<desc><marker id="receive_expr-3"/>

<p>Creates an abstract receive-expression. If <c>Timeout</c>
  is <c>none</c>, the result represents "<c>receive
  C1; ...; Cn end</c>" (the <c>Action</c>
  argument is ignored). Otherwise, if <c>Clauses</c> is
  <c>[C1, ..., Cn]</c> and <c>Action</c> is <c>[A1, ...,
  Am]</c>, the result represents "<c>receive C1; ...;
  Cn after Timeout -&gt; A1, ..., Am
  end</c>". More exactly, if each <c>Ci</c> represents
  "<c>(Pi) Gi -&gt; Bi</c>", then the
  result represents "<c>receive P1 G1 -&gt;
  B1; ...; Pn Gn -&gt; Bn ...
  end</c>".</p>
 
  <p>Note that in Erlang, a receive-expression must have at least one
  clause if no timeout part is specified.
 </p>
<p><em>See also:</em> <seemfa marker="#case_expr/2">case_expr/2</seemfa>, <seemfa marker="#clause/3">clause/3</seemfa>, <seemfa marker="#receive_expr/1">receive_expr/1</seemfa>, <seemfa marker="#receive_expr_action/1">receive_expr_action/1</seemfa>, <seemfa marker="#receive_expr_clauses/1">receive_expr_clauses/1</seemfa>, <seemfa marker="#receive_expr_timeout/1">receive_expr_timeout/1</seemfa>.</p>
</desc></func>
<func>
<name since="">receive_expr_action(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; [<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]</name>
<fsummary>Returns the list of action body subtrees of a
  receive_expr node.</fsummary>

<desc><marker id="receive_expr_action-1"/>

<p>Returns the list of action body subtrees of a
  <c>receive_expr</c> node. If <c>Node</c> represents
  "<c>receive C1; ...; Cn end</c>", this is the
  empty list.
 </p>
<p><em>See also:</em> <seemfa marker="#receive_expr/3">receive_expr/3</seemfa>.</p>
</desc></func>
<func>
<name since="">receive_expr_clauses(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; [<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]</name>
<fsummary>Returns the list of clause subtrees of a
  receive_expr node.</fsummary>

<desc><marker id="receive_expr_clauses-1"/>

<p>Returns the list of clause subtrees of a
  <c>receive_expr</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#receive_expr/3">receive_expr/3</seemfa>.</p>
</desc></func>
<func>
<name since="">receive_expr_timeout(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; none | <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the timeout subtree of a receive_expr node,
  if any.</fsummary>

<desc><marker id="receive_expr_timeout-1"/>

<p>Returns the timeout subtree of a <c>receive_expr</c> node,
  if any. If <c>Node</c> represents "<c>receive C1;
  ...; Cn end</c>", <c>none</c> is returned.
  Otherwise, if <c>Node</c> represents "<c>receive
  C1; ...; Cn after Timeout -&gt; ... end</c>",
  <c>Timeout</c> is returned.
 </p>
<p><em>See also:</em> <seemfa marker="#receive_expr/3">receive_expr/3</seemfa>.</p>
</desc></func>
<func>
<name since="">record_access(Argument::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Type::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Field::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract record field access expression.</fsummary>

<desc><marker id="record_access-3"/>

<p>Creates an abstract record field access expression. The result
  represents "<c>Argument#Type.Field</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#record_access_argument/1">record_access_argument/1</seemfa>, <seemfa marker="#record_access_field/1">record_access_field/1</seemfa>, <seemfa marker="#record_access_type/1">record_access_type/1</seemfa>, <seemfa marker="#record_expr/3">record_expr/3</seemfa>.</p>
</desc></func>
<func>
<name since="">record_access_argument(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the argument subtree of a record_access node.</fsummary>

<desc><marker id="record_access_argument-1"/>

<p>Returns the argument subtree of a <c>record_access</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#record_access/3">record_access/3</seemfa>.</p>
</desc></func>
<func>
<name since="">record_access_field(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the field subtree of a record_access node.</fsummary>

<desc><marker id="record_access_field-1"/>

<p>Returns the field subtree of a <c>record_access</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#record_access/3">record_access/3</seemfa>.</p>
</desc></func>
<func>
<name since="">record_access_type(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the type subtree of a record_access node.</fsummary>

<desc><marker id="record_access_type-1"/>

<p>Returns the type subtree of a <c>record_access</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#record_access/3">record_access/3</seemfa>.</p>
</desc></func>
<func>
<name since="">record_expr(Type::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Fields::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Equivalent to record_expr(none, Type, Fields).
</fsummary>

<desc><marker id="record_expr-2"/>
<p>Equivalent to <seemfa marker="#record_expr/3">record_expr(none, Type, Fields)</seemfa>.</p>
</desc></func>
<func>
<name since="">record_expr(Argument::none | <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Type::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Fields::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract record expression.</fsummary>

<desc><marker id="record_expr-3"/>

<p>Creates an abstract record expression. If <c>Fields</c> is
  <c>[F1, ..., Fn]</c>, then if <c>Argument</c> is
  <c>none</c>, the result represents
  "<c>#Type{F1, ..., Fn}</c>",
  otherwise it represents
  "<c>Argument#Type{F1, ...,
  Fn}</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#record_access/3">record_access/3</seemfa>, <seemfa marker="#record_expr/2">record_expr/2</seemfa>, <seemfa marker="#record_expr_argument/1">record_expr_argument/1</seemfa>, <seemfa marker="#record_expr_fields/1">record_expr_fields/1</seemfa>, <seemfa marker="#record_expr_type/1">record_expr_type/1</seemfa>, <seemfa marker="#record_field/2">record_field/2</seemfa>, <seemfa marker="#record_index_expr/2">record_index_expr/2</seemfa>.</p>
</desc></func>
<func>
<name since="">record_expr_argument(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; none | <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the argument subtree of a record_expr node,
  if any.</fsummary>

<desc><marker id="record_expr_argument-1"/>

<p>Returns the argument subtree of a <c>record_expr</c> node,
  if any. If <c>Node</c> represents
  "<c>#Type{...}</c>", <c>none</c> is returned.
  Otherwise, if <c>Node</c> represents
  "<c>Argument#Type{...}</c>",
  <c>Argument</c> is returned.
 </p>
<p><em>See also:</em> <seemfa marker="#record_expr/3">record_expr/3</seemfa>.</p>
</desc></func>
<func>
<name since="">record_expr_fields(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; [<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]</name>
<fsummary>Returns the list of field subtrees of a
  record_expr node.</fsummary>

<desc><marker id="record_expr_fields-1"/>

<p>Returns the list of field subtrees of a
  <c>record_expr</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#record_expr/3">record_expr/3</seemfa>.</p>
</desc></func>
<func>
<name since="">record_expr_type(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the type subtree of a record_expr node.</fsummary>

<desc><marker id="record_expr_type-1"/>

<p>Returns the type subtree of a <c>record_expr</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#record_expr/3">record_expr/3</seemfa>.</p>
</desc></func>
<func>
<name since="">record_field(Name::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Equivalent to record_field(Name, none).
</fsummary>

<desc><marker id="record_field-1"/>
<p>Equivalent to <seemfa marker="#record_field/2">record_field(Name, none)</seemfa>.</p>
</desc></func>
<func>
<name since="">record_field(Name::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Value::none | <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract record field specification.</fsummary>

<desc><marker id="record_field-2"/>

<p>Creates an abstract record field specification. If
  <c>Value</c> is <c>none</c>, the result represents
  simply "<c>Name</c>", otherwise it represents
  "<c>Name = Value</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#record_expr/3">record_expr/3</seemfa>, <seemfa marker="#record_field_name/1">record_field_name/1</seemfa>, <seemfa marker="#record_field_value/1">record_field_value/1</seemfa>.</p>
</desc></func>
<func>
<name since="">record_field_name(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the name subtree of a record_field node.</fsummary>

<desc><marker id="record_field_name-1"/>

<p>Returns the name subtree of a <c>record_field</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#record_field/2">record_field/2</seemfa>.</p>
</desc></func>
<func>
<name since="">record_field_value(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; none | <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the value subtree of a record_field node,
  if any.</fsummary>

<desc><marker id="record_field_value-1"/>

<p>Returns the value subtree of a <c>record_field</c> node,
  if any. If <c>Node</c> represents
  "<c>Name</c>", <c>none</c> is
  returned. Otherwise, if <c>Node</c> represents
  "<c>Name = Value</c>", <c>Value</c>
  is returned.
 </p>
<p><em>See also:</em> <seemfa marker="#record_field/2">record_field/2</seemfa>.</p>
</desc></func>
<func>
<name since="">record_index_expr(Type::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Field::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract record field index expression.</fsummary>

<desc><marker id="record_index_expr-2"/>

<p>Creates an abstract record field index expression. The result
  represents "<c>#Type.Field</c>".</p>
 
  <p>(Note: the function name <c>record_index/2</c> is reserved
  by the Erlang compiler, which is why that name could not be used
  for this constructor.)
 </p>
<p><em>See also:</em> <seemfa marker="#record_expr/3">record_expr/3</seemfa>, <seemfa marker="#record_index_expr_field/1">record_index_expr_field/1</seemfa>, <seemfa marker="#record_index_expr_type/1">record_index_expr_type/1</seemfa>.</p>
</desc></func>
<func>
<name since="">record_index_expr_field(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the field subtree of a record_index_expr node.</fsummary>

<desc><marker id="record_index_expr_field-1"/>

<p>Returns the field subtree of a <c>record_index_expr</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#record_index_expr/2">record_index_expr/2</seemfa>.</p>
</desc></func>
<func>
<name since="">record_index_expr_type(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the type subtree of a record_index_expr node.</fsummary>

<desc><marker id="record_index_expr_type-1"/>

<p>Returns the type subtree of a <c>record_index_expr</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#record_index_expr/2">record_index_expr/2</seemfa>.</p>
</desc></func>
<func>
<name since="">record_type(Name::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Fields::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract record type.</fsummary>

<desc><marker id="record_type-2"/>

<p>Creates an abstract record type. If <c>Fields</c> is
  <c>[F1, ..., Fn]</c>, the result represents
  "<c>#Name{F1, ..., Fn}</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#record_type_fields/1">record_type_fields/1</seemfa>, <seemfa marker="#record_type_name/1">record_type_name/1</seemfa>.</p>
</desc></func>
<func>
<name since="">record_type_field(Name::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Type::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract record type field.</fsummary>

<desc><marker id="record_type_field-2"/>

<p>Creates an abstract record type field. The result represents
  "<c>Name :: Type</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#record_type_field_name/1">record_type_field_name/1</seemfa>, <seemfa marker="#record_type_field_type/1">record_type_field_type/1</seemfa>.</p>
</desc></func>
<func>
<name since="">record_type_field_name(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the name subtree of a record_type_field node.</fsummary>

<desc><marker id="record_type_field_name-1"/>

<p>Returns the name subtree of a <c>record_type_field</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#record_type_field/2">record_type_field/2</seemfa>.</p>
</desc></func>
<func>
<name since="">record_type_field_type(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the type subtree of a record_type_field node.</fsummary>

<desc><marker id="record_type_field_type-1"/>

<p>Returns the type subtree of a <c>record_type_field</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#record_type_field/2">record_type_field/2</seemfa>.</p>
</desc></func>
<func>
<name since="">record_type_fields(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; [<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]</name>
<fsummary>Returns the fields subtree of a record_type node.</fsummary>

<desc><marker id="record_type_fields-1"/>

<p>Returns the fields subtree of a <c>record_type</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#record_type/2">record_type/2</seemfa>.</p>
</desc></func>
<func>
<name since="">record_type_name(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the name subtree of a record_type node.</fsummary>

<desc><marker id="record_type_name-1"/>

<p>Returns the name subtree of a <c>record_type</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#record_type/2">record_type/2</seemfa>.</p>
</desc></func>
<func>
<name since="">remove_comments(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Clears the associated comments of Node.</fsummary>

<desc><marker id="remove_comments-1"/>

<p>Clears the associated comments of <c>Node</c>.</p>
 
  <p>Note: This is equivalent to
  <c>set_precomments(set_postcomments(Node, []), [])</c>, but
  potentially more efficient.
 </p>
<p><em>See also:</em> <seemfa marker="#set_postcomments/2">set_postcomments/2</seemfa>, <seemfa marker="#set_precomments/2">set_precomments/2</seemfa>.</p>
</desc></func>
<func>
<name since="">revert(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns an erl_parse-compatible representation of a
  syntax tree, if possible.</fsummary>

<desc><marker id="revert-1"/>

<p>Returns an <c>erl_parse</c>-compatible representation of a
  syntax tree, if possible. If <c>Tree</c> represents a
  well-formed Erlang program or expression, the conversion should work
  without problems. Typically, <seemfa marker="#is_tree/1">is_tree/1</seemfa> yields
  <c>true</c> if conversion failed (i.e., the result is still an
  abstract syntax tree), and <c>false</c> otherwise.</p>
 
  <p>The <seemfa marker="#is_tree/1">is_tree/1</seemfa> test is not completely foolproof. For a
  few special node types (e.g. <c>arity_qualifier</c>), if such a
  node occurs in a context where it is not expected, it will be left
  unchanged as a non-reverted subtree of the result. This can only
  happen if <c>Tree</c> does not actually represent legal Erlang
  code.
 </p>
<p><em>See also:</em> <seeerl marker="stdlib:erl_parse">erl_parse(3)</seeerl>, <seemfa marker="#revert_forms/1">revert_forms/1</seemfa>.</p>
</desc></func>
<func>
<name since="">revert_forms(Forms::<seeerl marker="#type-forms">forms()</seeerl>) -&gt; [<seeerl marker="#type-erl_parse">erl_parse()</seeerl>]</name>
<fsummary>Reverts a sequence of Erlang source code forms.</fsummary>

<desc><marker id="revert_forms-1"/>

<p>Reverts a sequence of Erlang source code forms. The sequence can
  be given either as a <c>form_list</c> syntax tree (possibly
  nested), or as a list of "program form" syntax trees. If successful,
  the corresponding flat list of <c>erl_parse</c>-compatible
  syntax trees is returned (see <seemfa marker="#revert/1">revert/1</seemfa>). If some program
  form could not be reverted, <c>{error, Form}</c> is thrown.
  Standalone comments in the form sequence are discarded.
 </p>
<p><em>See also:</em> <seemfa marker="#form_list/1">form_list/1</seemfa>, <seemfa marker="#is_form/1">is_form/1</seemfa>, <seemfa marker="#revert/1">revert/1</seemfa>.</p>
</desc></func>
<func>
<name since="">set_ann(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, As::[term()]) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Sets the list of user annotations of Node to Annotations.</fsummary>

<desc><marker id="set_ann-2"/>

<p>Sets the list of user annotations of <c>Node</c> to <c>Annotations</c>.
 </p>
<p><em>See also:</em> <seemfa marker="#add_ann/2">add_ann/2</seemfa>, <seemfa marker="#copy_ann/2">copy_ann/2</seemfa>, <seemfa marker="#get_ann/1">get_ann/1</seemfa>.</p>
</desc></func>
<func>
<name since="">set_attrs(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Attr::<seeerl marker="#type-syntaxTreeAttributes">syntaxTreeAttributes()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Sets the attributes of Node to Attributes.</fsummary>

<desc><marker id="set_attrs-2"/>

<p>Sets the attributes of <c>Node</c> to <c>Attributes</c>.
 </p>
<p><em>See also:</em> <seemfa marker="#copy_attrs/2">copy_attrs/2</seemfa>, <seemfa marker="#get_attrs/1">get_attrs/1</seemfa>.</p>
</desc></func>
<func>
<name since="">set_pos(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Pos::<seeerl marker="#type-annotation_or_location">annotation_or_location()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Sets the position information of Node to Pos.</fsummary>

<desc><marker id="set_pos-2"/>

<p>Sets the position information of <c>Node</c> to <c>Pos</c>.
 </p>
<p><em>See also:</em> <seemfa marker="#copy_pos/2">copy_pos/2</seemfa>, <seemfa marker="#get_pos/1">get_pos/1</seemfa>.</p>
</desc></func>
<func>
<name since="">set_postcomments(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Cs::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Sets the post-comments of Node to
  Comments.</fsummary>

<desc><marker id="set_postcomments-2"/>

<p>Sets the post-comments of <c>Node</c> to
  <c>Comments</c>. <c>Comments</c> should be a possibly
  empty list of abstract comments, in top-down textual order
 </p>
<p><em>See also:</em> <seemfa marker="#add_postcomments/2">add_postcomments/2</seemfa>, <seemfa marker="#comment/2">comment/2</seemfa>, <seemfa marker="#copy_comments/2">copy_comments/2</seemfa>, <seemfa marker="#get_postcomments/1">get_postcomments/1</seemfa>, <seemfa marker="#join_comments/2">join_comments/2</seemfa>, <seemfa marker="#remove_comments/1">remove_comments/1</seemfa>, <seemfa marker="#set_precomments/2">set_precomments/2</seemfa>.</p>
</desc></func>
<func>
<name since="">set_precomments(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Cs::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Sets the pre-comments of Node to
  Comments.</fsummary>

<desc><marker id="set_precomments-2"/>

<p>Sets the pre-comments of <c>Node</c> to
  <c>Comments</c>. <c>Comments</c> should be a possibly
  empty list of abstract comments, in top-down textual order.
 </p>
<p><em>See also:</em> <seemfa marker="#add_precomments/2">add_precomments/2</seemfa>, <seemfa marker="#comment/2">comment/2</seemfa>, <seemfa marker="#copy_comments/2">copy_comments/2</seemfa>, <seemfa marker="#get_precomments/1">get_precomments/1</seemfa>, <seemfa marker="#join_comments/2">join_comments/2</seemfa>, <seemfa marker="#remove_comments/1">remove_comments/1</seemfa>, <seemfa marker="#set_postcomments/2">set_postcomments/2</seemfa>.</p>
</desc></func>
<func>
<name since="">size_qualifier(Body::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Size::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract size qualifier.</fsummary>

<desc><marker id="size_qualifier-2"/>

<p>Creates an abstract size qualifier. The result represents
  "<c>Body:Size</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#size_qualifier_argument/1">size_qualifier_argument/1</seemfa>, <seemfa marker="#size_qualifier_body/1">size_qualifier_body/1</seemfa>.</p>
</desc></func>
<func>
<name since="">size_qualifier_argument(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the argument subtree (the size) of a
  size_qualifier node.</fsummary>

<desc><marker id="size_qualifier_argument-1"/>

<p>Returns the argument subtree (the size) of a
  <c>size_qualifier</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#size_qualifier/2">size_qualifier/2</seemfa>.</p>
</desc></func>
<func>
<name since="">size_qualifier_body(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the body subtree of a size_qualifier node.</fsummary>

<desc><marker id="size_qualifier_body-1"/>

<p>Returns the body subtree of a <c>size_qualifier</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#size_qualifier/2">size_qualifier/2</seemfa>.</p>
</desc></func>
<func>
<name since="">string(String::string()) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract string literal.</fsummary>

<desc><marker id="string-1"/>

<p>Creates an abstract string literal. The result represents
  <c>"Text"</c> (including the surrounding
  double-quotes), where <c>Text</c> corresponds to the sequence
  of characters in <c>Value</c>, but not representing a
  <em>specific</em> string literal.</p>
 
  <p>For example, the result of <c>string("x\ny")</c> represents any and all of
  <c>"x\ny"</c>, <c>"x\12y"</c>, <c>"x\012y"</c> and <c>"x\^Jy"</c>; see <seemfa marker="#char/1">char/1</seemfa>.
 </p>
<p><em>See also:</em> <seemfa marker="#char/1">char/1</seemfa>, <seemfa marker="#is_string/2">is_string/2</seemfa>, <seemfa marker="#string_literal/1">string_literal/1</seemfa>, <seemfa marker="#string_literal/2">string_literal/2</seemfa>, <seemfa marker="#string_value/1">string_value/1</seemfa>.</p>
</desc></func>
<func>
<name since="">string_literal(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; nonempty_string()</name>
<fsummary>Returns the literal string represented by a string
  node.</fsummary>

<desc><marker id="string_literal-1"/>

<p>Returns the literal string represented by a <c>string</c>
  node. This includes surrounding double-quote characters.
  Characters beyond 255 will be escaped.
 </p>
<p><em>See also:</em> <seemfa marker="#string/1">string/1</seemfa>.</p>
</desc></func>
<func>
<name since="">string_literal(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, X2::<seeerl marker="#type-encoding">encoding()</seeerl>) -&gt; nonempty_string()</name>
<fsummary>Returns the literal string represented by a string
  node.</fsummary>

<desc><marker id="string_literal-2"/>

<p>Returns the literal string represented by a <c>string</c>
  node. This includes surrounding double-quote characters.
  Depending on the encoding characters beyond 255 will be escaped
  (<c>latin1</c>) or copied as is (<c>utf8</c>).
 </p>
<p><em>See also:</em> <seemfa marker="#string/1">string/1</seemfa>.</p>
</desc></func>
<func>
<name since="">string_value(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; string()</name>
<fsummary>Returns the value represented by a string node.</fsummary>

<desc><marker id="string_value-1"/>

<p>Returns the value represented by a <c>string</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#string/1">string/1</seemfa>.</p>
</desc></func>
<func>
<name since="">subtrees(T::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; [[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]]</name>
<fsummary>Returns the grouped list of all subtrees of a syntax tree.</fsummary>

<desc><marker id="subtrees-1"/>

<p>Returns the grouped list of all subtrees of a syntax tree. If
  <c>Node</c> is a leaf node (see <seemfa marker="#is_leaf/1">is_leaf/1</seemfa>), this
  is the empty list, otherwise the result is always a nonempty list,
  containing the lists of subtrees of <c>Node</c>, in  
left-to-right order as they occur in the printed program text, and  
grouped by category. Often, each group contains only a single  
subtree.</p>
 
  <p>Depending on the type of <c>Node</c>, the size of some  
groups may be variable (e.g., the group consisting of all the  
elements of a tuple), while others always contain the same number of  
elements - usually exactly one (e.g., the group containing the  
argument expression of a case-expression). Note, however, that the  
exact structure of the returned list (for a given node type) should  
in general not be depended upon, since it might be subject to change  
without notice.</p>
 
  <p>The function <seemfa marker="#subtrees/1">subtrees/1</seemfa> and the constructor functions
  <seemfa marker="#make_tree/2">make_tree/2</seemfa> and <seemfa marker="#update_tree/2">update_tree/2</seemfa> can be a  
great help if one wants to traverse a syntax tree, visiting all its  
subtrees, but treat nodes of the tree in a uniform way in most or all  
cases. Using these functions makes this simple, and also assures that  
your code is not overly sensitive to extensions of the syntax tree  
data type, because any node types not explicitly handled by your code  
can be left to a default case.</p>
 
  <p>For example:
  </p><pre>     postorder(F, Tree) -&gt;
        F(case subtrees(Tree) of
            [] -&gt; Tree;
            List -&gt; update_tree(Tree,
                                [[postorder(F, Subtree)
                                  || Subtree &amp;lt;- Group]
                                 || Group &amp;lt;- List])
          end).</pre><p>
  maps the function <c>F</c> on <c>Tree</c> and all its
  subtrees, doing a post-order traversal of the syntax tree. (Note the
  use of <seemfa marker="#update_tree/2">update_tree/2</seemfa> to preserve node attributes.) For a
  simple function like:
  </p><pre>     f(Node) -&gt;
        case type(Node) of
            atom -&gt; atom("a_" ++ atom_name(Node));
            _ -&gt; Node
        end.</pre><p>
  the call <c>postorder(fun f/1, Tree)</c> will yield a new
  representation of <c>Tree</c> in which all atom names have been
  extended with the prefix "a_", but nothing else (including comments,
  annotations and line numbers) has been changed.
 </p>
<p><em>See also:</em> <seemfa marker="#copy_attrs/2">copy_attrs/2</seemfa>, <seemfa marker="#is_leaf/1">is_leaf/1</seemfa>, <seemfa marker="#make_tree/2">make_tree/2</seemfa>, <seemfa marker="#type/1">type/1</seemfa>.</p>
</desc></func>
<func>
<name since="">text(String::string()) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract piece of source code text.</fsummary>

<desc><marker id="text-1"/>

<p>Creates an abstract piece of source code text. The result
  represents exactly the sequence of characters in <c>String</c>.
  This is useful in cases when one wants full control of the resulting
  output, e.g., for the appearance of floating-point numbers or macro
  definitions.
 </p>
<p><em>See also:</em> <seemfa marker="#text_string/1">text_string/1</seemfa>.</p>
</desc></func>
<func>
<name since="">text_string(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; string()</name>
<fsummary>Returns the character sequence represented by a text node.</fsummary>

<desc><marker id="text_string-1"/>

<p>Returns the character sequence represented by a <c>text</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#text/1">text/1</seemfa>.</p>
</desc></func>
<func>
<name since="">tree(Type::atom()) -&gt; <seeerl marker="#type-tree">tree()</seeerl></name>
<fsummary>Equivalent to tree(Type, []).
</fsummary>

<desc><marker id="tree-1"/>
<p>Equivalent to <seemfa marker="#tree/2">tree(Type, [])</seemfa>.</p>
</desc></func>
<func>
<name since="">tree(Type::atom(), Data::term()) -&gt; <seeerl marker="#type-tree">tree()</seeerl></name>
<fsummary>For special purposes only.</fsummary>

<desc><marker id="tree-2"/>

<p><em>For special purposes only</em>. Creates an abstract syntax
  tree node with type tag <c>Type</c> and associated data
  <c>Data</c>.</p>
 
  <p>This function and the related <seemfa marker="#is_tree/1">is_tree/1</seemfa> and
  <seemfa marker="#data/1">data/1</seemfa> provide a uniform way to extend the set of
  <c>erl_parse</c> node types. The associated data is any term,  
whose format may depend on the type tag.</p>
 
  <p><marker id="Notes:"/><em>Notes:</em>
  </p><list>
   <item><p>Any nodes created outside of this module must have type tags
       distinct from those currently defined by this module; see
       <seemfa marker="#type/1">type/1</seemfa> for a complete list.</p></item>
   <item><p>The type tag of a syntax tree node may also be used
       as a primary tag by the <c>erl_parse</c> representation;
       in that case, the selector functions for that node type
       <em>must</em> handle both the abstract syntax tree and the
       <c>erl_parse</c> form. The function <c>type(T)</c>
       should return the correct type tag regardless of the
       representation of <c>T</c>, so that the user sees no
       difference between <c>erl_syntax</c> and
       <c>erl_parse</c> nodes.</p></item>
  </list><p>
 </p>
<p><em>See also:</em> <seemfa marker="#data/1">data/1</seemfa>, <seemfa marker="#is_tree/1">is_tree/1</seemfa>, <seemfa marker="#type/1">type/1</seemfa>.</p>
</desc></func>
<func>
<name since="">try_after_expr(Body::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>], After::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Equivalent to try_expr(Body, [], [], After).
</fsummary>

<desc><marker id="try_after_expr-2"/>
<p>Equivalent to <seemfa marker="#try_expr/4">try_expr(Body, [], [], After)</seemfa>.</p>
</desc></func>
<func>
<name since="">try_expr(Body::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>], Handlers::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Equivalent to try_expr(Body, [], Handlers).
</fsummary>

<desc><marker id="try_expr-2"/>
<p>Equivalent to <seemfa marker="#try_expr/3">try_expr(Body, [], Handlers)</seemfa>.</p>
</desc></func>
<func>
<name since="">try_expr(Body::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>], Clauses::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>], Handlers::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Equivalent to try_expr(Body, Clauses, Handlers, []).
</fsummary>

<desc><marker id="try_expr-3"/>
<p>Equivalent to <seemfa marker="#try_expr/4">try_expr(Body, Clauses, Handlers, [])</seemfa>.</p>
</desc></func>
<func>
<name since="">try_expr(Body::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>], Clauses::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>], Handlers::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>], After::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract try-expression.</fsummary>

<desc><marker id="try_expr-4"/>

<p>Creates an abstract try-expression. If <c>Body</c> is
  <c>[B1, ..., Bn]</c>, <c>Clauses</c> is <c>[C1, ...,
  Cj]</c>, <c>Handlers</c> is <c>[H1, ..., Hk]</c>, and
  <c>After</c> is <c>[A1, ..., Am]</c>, the result
  represents "<c>try B1, ..., Bn of C1;
  ...; Cj catch H1; ...; Hk after
  A1, ..., Am end</c>". More exactly, if each
  <c>Ci</c> represents "<c>(CPi) CGi -&gt;
  CBi</c>", and each <c>Hi</c> represents
  "<c>(HPi) HGi -&gt; HBi</c>", then the
  result represents "<c>try B1, ..., Bn of
  CP1 CG1 -&gt; CB1; ...; CPj
  CGj -&gt; CBj catch HP1 HG1 -&gt;
  HB1; ...; HPk HGk -&gt; HBk after
  A1, ..., Am end</c>"; see
  <seemfa marker="#case_expr/2">case_expr/2</seemfa>. If <c>Clauses</c> is the empty list,
  the <c>of ...</c> section is left out. If <c>After</c> is
  the empty list, the <c>after ...</c> section is left out. If
  <c>Handlers</c> is the empty list, and <c>After</c> is
  nonempty, the <c>catch ...</c> section is left out.
 </p>
<p><em>See also:</em> <seemfa marker="#case_expr/2">case_expr/2</seemfa>, <seemfa marker="#class_qualifier/2">class_qualifier/2</seemfa>, <seemfa marker="#clause/3">clause/3</seemfa>, <seemfa marker="#try_after_expr/2">try_after_expr/2</seemfa>, <seemfa marker="#try_expr/2">try_expr/2</seemfa>, <seemfa marker="#try_expr/3">try_expr/3</seemfa>, <seemfa marker="#try_expr_after/1">try_expr_after/1</seemfa>, <seemfa marker="#try_expr_body/1">try_expr_body/1</seemfa>, <seemfa marker="#try_expr_clauses/1">try_expr_clauses/1</seemfa>, <seemfa marker="#try_expr_handlers/1">try_expr_handlers/1</seemfa>.</p>
</desc></func>
<func>
<name since="">try_expr_after(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; [<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]</name>
<fsummary>Returns the list of "after" subtrees of a try_expr node.</fsummary>

<desc><marker id="try_expr_after-1"/>

<p>Returns the list of "after" subtrees of a <c>try_expr</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#try_expr/4">try_expr/4</seemfa>.</p>
</desc></func>
<func>
<name since="">try_expr_body(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; [<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]</name>
<fsummary>Returns the list of body subtrees of a try_expr node.</fsummary>

<desc><marker id="try_expr_body-1"/>

<p>Returns the list of body subtrees of a <c>try_expr</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#try_expr/4">try_expr/4</seemfa>.</p>
</desc></func>
<func>
<name since="">try_expr_clauses(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; [<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]</name>
<fsummary>Returns the list of case-clause subtrees of a
  try_expr node.</fsummary>

<desc><marker id="try_expr_clauses-1"/>

<p>Returns the list of case-clause subtrees of a
  <c>try_expr</c> node. If <c>Node</c> represents
  "<c>try Body catch H1; ...; Hn
  end</c>", the result is the empty list.
 </p>
<p><em>See also:</em> <seemfa marker="#try_expr/4">try_expr/4</seemfa>.</p>
</desc></func>
<func>
<name since="">try_expr_handlers(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; [<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]</name>
<fsummary>Returns the list of handler-clause subtrees of a
  try_expr node.</fsummary>

<desc><marker id="try_expr_handlers-1"/>

<p>Returns the list of handler-clause subtrees of a
  <c>try_expr</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#try_expr/4">try_expr/4</seemfa>.</p>
</desc></func>
<func>
<name since="">tuple(List::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract tuple.</fsummary>

<desc><marker id="tuple-1"/>

<p>Creates an abstract tuple. If <c>Elements</c> is
  <c>[X1, ..., Xn]</c>, the result represents
  "<c>{X1, ..., Xn}</c>".</p>
 
  <p>Note: The Erlang language has distinct 1-tuples, i.e.,
  <c>{X}</c> is always distinct from <c>X</c> itself.
 </p>
<p><em>See also:</em> <seemfa marker="#tuple_elements/1">tuple_elements/1</seemfa>, <seemfa marker="#tuple_size/1">tuple_size/1</seemfa>.</p>
</desc></func>
<func>
<name since="">tuple_elements(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; [<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]</name>
<fsummary>Returns the list of element subtrees of a tuple node.</fsummary>

<desc><marker id="tuple_elements-1"/>

<p>Returns the list of element subtrees of a <c>tuple</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#tuple/1">tuple/1</seemfa>.</p>
</desc></func>
<func>
<name since="">tuple_size(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; non_neg_integer()</name>
<fsummary>Returns the number of elements of a tuple node.</fsummary>

<desc><marker id="tuple_size-1"/>

<p>Returns the number of elements of a <c>tuple</c> node.</p>
 
  <p>Note: this is equivalent to
  <c>length(tuple_elements(Node))</c>, but potentially more
  efficient.
 </p>
<p><em>See also:</em> <seemfa marker="#tuple/1">tuple/1</seemfa>, <seemfa marker="#tuple_elements/1">tuple_elements/1</seemfa>.</p>
</desc></func>
<func>
<name since="">tuple_type() -&gt; term()
</name>
<fsummary>Equivalent to tuple_type(any_size).
</fsummary>

<desc><marker id="tuple_type-0"/>
<p>Equivalent to <seemfa marker="#tuple_type/1">tuple_type(any_size)</seemfa>.</p>
</desc></func>
<func>
<name since="">tuple_type(Elements::any_size | [<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract type tuple.</fsummary>

<desc><marker id="tuple_type-1"/>

<p>Creates an abstract type tuple. If <c>Elements</c> is
  <c>[T1, ..., Tn]</c>, the result represents
  "<c>{T1, ..., Tn}</c>";
  otherwise, if <c>Elements</c> is <c>any_size</c>, it represents
  "<c>tuple()</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#tuple_type_elements/1">tuple_type_elements/1</seemfa>.</p>
</desc></func>
<func>
<name since="">tuple_type_elements(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; any_size | [<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]</name>
<fsummary>Returns the list of type element subtrees of a tuple_type node.</fsummary>

<desc><marker id="tuple_type_elements-1"/>

<p>Returns the list of type element subtrees of a <c>tuple_type</c> node.
  If <c>Node</c> represents "<c>tuple()</c>", <c>any_size</c> is returned;
  otherwise, if <c>Node</c> represents
  "<c>{T1, ..., Tn}</c>",
  <c>[T1, ..., Tn]</c> is returned.
 </p>
<p><em>See also:</em> <seemfa marker="#tuple_type/0">tuple_type/0</seemfa>, <seemfa marker="#tuple_type/1">tuple_type/1</seemfa>.</p>
</desc></func>
<func>
<name since="">type(Tree::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; atom()</name>
<fsummary>Returns the type tag of Node.</fsummary>

<desc><marker id="type-1"/>

<p>Returns the type tag of <c>Node</c>. If <c>Node</c>
  does not represent a syntax tree, evaluation fails with reason
  <c>badarg</c>. Node types currently defined by this module are:</p>
 
  <p>
   
    application
    annotated_type
    arity_qualifier
    atom
   <br/>
    attribute
    binary
    binary_field
    bitstring_type
   <br/>
    block_expr
    case_expr
    catch_expr
    char
   <br/>
    class_qualifier
    clause
    comment
    conjunction
   <br/>
    constrained_function_type
    constraint
    disjunction
   <br/>
    else_expr
    eof_marker
    error_marker
   <br/>
    float
    form_list
    fun_expr
    fun_type
    function
    function_type
    generator
   <br/>
    if_expr
    implicit_fun
    infix_expr
    integer
   <br/>
    integer_range_type
    list
    list_comp
    macro
   <br/>
    map_expr
    map_field_assoc
    map_field_exact
    map_type
   <br/>
    map_type_assoc
    map_type_exact
    match_expr
   <br/>
    maybe_expr
    maybe_match_expr
    module_qualifier
   <br/>
    named_fun_expr
    nil
    operator
    parentheses
   <br/>
    prefix_expr
    receive_expr
    record_access
    record_expr
   <br/>
    record_field
    record_index_expr
    record_type
    record_type_field
   <br/>
    size_qualifier
    string
    text
    try_expr
   <br/>
    tuple
    tuple_type
    typed_record_field
    type_application
   <br/>
    type_union
    underscore
    user_type_application
    variable
   <br/>
    warning_marker
   <br/>
  </p>
 
  <p>The user may (for special purposes) create additional nodes
  with other type tags, using the <seemfa marker="#tree/2">tree/2</seemfa> function.</p>
 
  <p>Note: The primary constructor functions for a node type should
  always have the same name as the node type itself.
 </p>
<p><em>See also:</em> <seemfa marker="#annotated_type/2">annotated_type/2</seemfa>, <seemfa marker="#application/3">application/3</seemfa>, <seemfa marker="#arity_qualifier/2">arity_qualifier/2</seemfa>, <seemfa marker="#atom/1">atom/1</seemfa>, <seemfa marker="#attribute/2">attribute/2</seemfa>, <seemfa marker="#binary/1">binary/1</seemfa>, <seemfa marker="#binary_field/2">binary_field/2</seemfa>, <seemfa marker="#bitstring_type/2">bitstring_type/2</seemfa>, <seemfa marker="#block_expr/1">block_expr/1</seemfa>, <seemfa marker="#case_expr/2">case_expr/2</seemfa>, <seemfa marker="#catch_expr/1">catch_expr/1</seemfa>, <seemfa marker="#char/1">char/1</seemfa>, <seemfa marker="#class_qualifier/2">class_qualifier/2</seemfa>, <seemfa marker="#clause/3">clause/3</seemfa>, <seemfa marker="#comment/2">comment/2</seemfa>, <seemfa marker="#conjunction/1">conjunction/1</seemfa>, <seemfa marker="#constrained_function_type/2">constrained_function_type/2</seemfa>, <seemfa marker="#constraint/2">constraint/2</seemfa>, <seemfa marker="#disjunction/1">disjunction/1</seemfa>, <seemfa marker="#else_expr/1">else_expr/1</seemfa>, <seemfa marker="#eof_marker/0">eof_marker/0</seemfa>, <seemfa marker="#error_marker/1">error_marker/1</seemfa>, <seemfa marker="#float/1">float/1</seemfa>, <seemfa marker="#form_list/1">form_list/1</seemfa>, <seemfa marker="#fun_expr/1">fun_expr/1</seemfa>, <seemfa marker="#fun_type/0">fun_type/0</seemfa>, <seemfa marker="#function/2">function/2</seemfa>, <seemfa marker="#function_type/1">function_type/1</seemfa>, <seemfa marker="#function_type/2">function_type/2</seemfa>, <seemfa marker="#generator/2">generator/2</seemfa>, <seemfa marker="#if_expr/1">if_expr/1</seemfa>, <seemfa marker="#implicit_fun/2">implicit_fun/2</seemfa>, <seemfa marker="#infix_expr/3">infix_expr/3</seemfa>, <seemfa marker="#integer/1">integer/1</seemfa>, <seemfa marker="#integer_range_type/2">integer_range_type/2</seemfa>, <seemfa marker="#list/2">list/2</seemfa>, <seemfa marker="#list_comp/2">list_comp/2</seemfa>, <seemfa marker="#macro/2">macro/2</seemfa>, <seemfa marker="#map_expr/2">map_expr/2</seemfa>, <seemfa marker="#map_field_assoc/2">map_field_assoc/2</seemfa>, <seemfa marker="#map_field_exact/2">map_field_exact/2</seemfa>, <seemfa marker="#map_type/0">map_type/0</seemfa>, <seemfa marker="#map_type/1">map_type/1</seemfa>, <seemfa marker="#map_type_assoc/2">map_type_assoc/2</seemfa>, <seemfa marker="#map_type_exact/2">map_type_exact/2</seemfa>, <seemfa marker="#match_expr/2">match_expr/2</seemfa>, <seemfa marker="#maybe_expr/1">maybe_expr/1</seemfa>, <seemfa marker="#maybe_expr/2">maybe_expr/2</seemfa>, <seemfa marker="#maybe_match_expr/2">maybe_match_expr/2</seemfa>, <seemfa marker="#module_qualifier/2">module_qualifier/2</seemfa>, <seemfa marker="#named_fun_expr/2">named_fun_expr/2</seemfa>, <seemfa marker="#nil/0">nil/0</seemfa>, <seemfa marker="#operator/1">operator/1</seemfa>, <seemfa marker="#parentheses/1">parentheses/1</seemfa>, <seemfa marker="#prefix_expr/2">prefix_expr/2</seemfa>, <seemfa marker="#receive_expr/3">receive_expr/3</seemfa>, <seemfa marker="#record_access/3">record_access/3</seemfa>, <seemfa marker="#record_expr/2">record_expr/2</seemfa>, <seemfa marker="#record_field/2">record_field/2</seemfa>, <seemfa marker="#record_index_expr/2">record_index_expr/2</seemfa>, <seemfa marker="#record_type/2">record_type/2</seemfa>, <seemfa marker="#record_type_field/2">record_type_field/2</seemfa>, <seemfa marker="#size_qualifier/2">size_qualifier/2</seemfa>, <seemfa marker="#string/1">string/1</seemfa>, <seemfa marker="#text/1">text/1</seemfa>, <seemfa marker="#tree/2">tree/2</seemfa>, <seemfa marker="#try_expr/3">try_expr/3</seemfa>, <seemfa marker="#tuple/1">tuple/1</seemfa>, <seemfa marker="#tuple_type/0">tuple_type/0</seemfa>, <seemfa marker="#tuple_type/1">tuple_type/1</seemfa>, <seemfa marker="#type_application/2">type_application/2</seemfa>, <seemfa marker="#type_union/1">type_union/1</seemfa>, <seemfa marker="#typed_record_field/2">typed_record_field/2</seemfa>, <seemfa marker="#underscore/0">underscore/0</seemfa>, <seemfa marker="#user_type_application/2">user_type_application/2</seemfa>, <seemfa marker="#variable/1">variable/1</seemfa>, <seemfa marker="#warning_marker/1">warning_marker/1</seemfa>.</p>
</desc></func>
<func>
<name since="">type_application(TypeName::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Arguments::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract type application expression.</fsummary>

<desc><marker id="type_application-2"/>

<p>Creates an abstract type application expression. If <c>Arguments</c> is
  <c>[T1, ..., Tn]</c>, the result represents
  "<c>TypeName(T1, ...Tn)</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#type_application/3">type_application/3</seemfa>, <seemfa marker="#type_application_arguments/1">type_application_arguments/1</seemfa>, <seemfa marker="#type_application_name/1">type_application_name/1</seemfa>, <seemfa marker="#user_type_application/2">user_type_application/2</seemfa>.</p>
</desc></func>
<func>
<name since="">type_application(Module::none | <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, TypeName::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Arguments::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract type application expression.</fsummary>

<desc><marker id="type_application-3"/>

<p>Creates an abstract type application expression. If
  <c>Module</c> is <c>none</c>, this is call is equivalent
  to <c>type_application(TypeName, Arguments)</c>, otherwise it is
  equivalent to <c>type_application(module_qualifier(Module, TypeName),
  Arguments)</c>.</p>
 
  <p>(This is a utility function.)
 </p>
<p><em>See also:</em> <seemfa marker="#module_qualifier/2">module_qualifier/2</seemfa>, <seemfa marker="#type_application/2">type_application/2</seemfa>.</p>
</desc></func>
<func>
<name since="">type_application_arguments(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; [<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]</name>
<fsummary>Returns the arguments subtrees of a type_application node.</fsummary>

<desc><marker id="type_application_arguments-1"/>

<p>Returns the arguments subtrees of a <c>type_application</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#type_application/2">type_application/2</seemfa>.</p>
</desc></func>
<func>
<name since="">type_application_name(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the type name subtree of a type_application node.</fsummary>

<desc><marker id="type_application_name-1"/>

<p>Returns the type name subtree of a <c>type_application</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#type_application/2">type_application/2</seemfa>.</p>
</desc></func>
<func>
<name since="">type_union(Types::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract type union.</fsummary>

<desc><marker id="type_union-1"/>

<p>Creates an abstract type union. If <c>Types</c> is
  <c>[T1, ..., Tn]</c>, the result represents
  "<c>T1 | ... | Tn</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#type_union_types/1">type_union_types/1</seemfa>.</p>
</desc></func>
<func>
<name since="">type_union_types(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; [<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]</name>
<fsummary>Returns the list of type subtrees of a type_union node.</fsummary>

<desc><marker id="type_union_types-1"/>

<p>Returns the list of type subtrees of a <c>type_union</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#type_union/1">type_union/1</seemfa>.</p>
</desc></func>
<func>
<name since="">typed_record_field(Field::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Type::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract typed record field specification.</fsummary>

<desc><marker id="typed_record_field-2"/>

<p>Creates an abstract typed record field specification. The
  result represents "<c>Field :: Type</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#typed_record_field_body/1">typed_record_field_body/1</seemfa>, <seemfa marker="#typed_record_field_type/1">typed_record_field_type/1</seemfa>.</p>
</desc></func>
<func>
<name since="">typed_record_field_body(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the field subtree of a typed_record_field node.</fsummary>

<desc><marker id="typed_record_field_body-1"/>

<p>Returns the field subtree of a <c>typed_record_field</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#typed_record_field/2">typed_record_field/2</seemfa>.</p>
</desc></func>
<func>
<name since="">typed_record_field_type(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the type subtree of a typed_record_field node.</fsummary>

<desc><marker id="typed_record_field_type-1"/>

<p>Returns the type subtree of a <c>typed_record_field</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#typed_record_field/2">typed_record_field/2</seemfa>.</p>
</desc></func>
<func>
<name since="">underscore() -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract universal pattern ("_").</fsummary>

<desc><marker id="underscore-0"/>

<p>Creates an abstract universal pattern ("<c>_</c>"). The
  lexical representation is a single underscore character. Note that
  this is <em>not</em> a variable, lexically speaking.
 </p>
<p><em>See also:</em> <seemfa marker="#variable/1">variable/1</seemfa>.</p>
</desc></func>
<func>
<name since="">update_tree(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Groups::[[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]]) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates a syntax tree with the same type and attributes as the
  given tree.</fsummary>

<desc><marker id="update_tree-2"/>

<p>Creates a syntax tree with the same type and attributes as the
  given tree. This is equivalent to <c>copy_attrs(Node,
  make_tree(type(Node), Groups))</c>.
 </p>
<p><em>See also:</em> <seemfa marker="#copy_attrs/2">copy_attrs/2</seemfa>, <seemfa marker="#make_tree/2">make_tree/2</seemfa>, <seemfa marker="#type/1">type/1</seemfa>.</p>
</desc></func>
<func>
<name since="">user_type_application(TypeName::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>, Arguments::[<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract user type.</fsummary>

<desc><marker id="user_type_application-2"/>

<p>Creates an abstract user type. If <c>Arguments</c> is
  <c>[T1, ..., Tn]</c>, the result represents
  "<c>TypeName(T1, ...Tn)</c>".
 </p>
<p><em>See also:</em> <seemfa marker="#type_application/2">type_application/2</seemfa>, <seemfa marker="#user_type_application_arguments/1">user_type_application_arguments/1</seemfa>, <seemfa marker="#user_type_application_name/1">user_type_application_name/1</seemfa>.</p>
</desc></func>
<func>
<name since="">user_type_application_arguments(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; [<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>]</name>
<fsummary>Returns the arguments subtrees of a user_type_application node.</fsummary>

<desc><marker id="user_type_application_arguments-1"/>

<p>Returns the arguments subtrees of a <c>user_type_application</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#user_type_application/2">user_type_application/2</seemfa>.</p>
</desc></func>
<func>
<name since="">user_type_application_name(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Returns the type name subtree of a user_type_application node.</fsummary>

<desc><marker id="user_type_application_name-1"/>

<p>Returns the type name subtree of a <c>user_type_application</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#user_type_application/2">user_type_application/2</seemfa>.</p>
</desc></func>
<func>
<name since="">variable(Name::atom() | string()) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract variable with the given name.</fsummary>

<desc><marker id="variable-1"/>

<p>Creates an abstract variable with the given name.
  <c>Name</c> may be any atom or string that represents a
  lexically valid variable name, but <em>not</em> a single underscore
  character; see <seemfa marker="#underscore/0">underscore/0</seemfa>.</p>
 
  <p>Note: no checking is done whether the character sequence
  represents a proper variable name, i.e., whether or not its first
  character is an uppercase Erlang character, or whether it does not
  contain control characters, whitespace, etc.
 </p>
<p><em>See also:</em> <seemfa marker="#underscore/0">underscore/0</seemfa>, <seemfa marker="#variable_literal/1">variable_literal/1</seemfa>, <seemfa marker="#variable_name/1">variable_name/1</seemfa>.</p>
</desc></func>
<func>
<name since="">variable_literal(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; string()</name>
<fsummary>Returns the name of a variable node as a string.</fsummary>

<desc><marker id="variable_literal-1"/>

<p>Returns the name of a <c>variable</c> node as a string.
 </p>
<p><em>See also:</em> <seemfa marker="#variable/1">variable/1</seemfa>.</p>
</desc></func>
<func>
<name since="">variable_name(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; atom()</name>
<fsummary>Returns the name of a variable node as an atom.</fsummary>

<desc><marker id="variable_name-1"/>

<p>Returns the name of a <c>variable</c> node as an atom.
 </p>
<p><em>See also:</em> <seemfa marker="#variable/1">variable/1</seemfa>.</p>
</desc></func>
<func>
<name since="">warning_marker(Warning::term()) -&gt; <seeerl marker="#type-syntaxTree">syntaxTree()</seeerl></name>
<fsummary>Creates an abstract warning marker.</fsummary>

<desc><marker id="warning_marker-1"/>

<p>Creates an abstract warning marker. The result represents an
  occurrence of a possible problem in the source code, with an
  associated Erlang I/O ErrorInfo structure given by <c>Error</c>
  (see module <seeerl marker="stdlib:io">io(3)</seeerl> for details). Warning markers are  
regarded as source code forms, but have no defined lexical form.</p>
 
  <p>Note: this is supported only for backwards compatibility with
  existing parsers and tools.
 </p>
<p><em>See also:</em> <seemfa marker="#eof_marker/0">eof_marker/0</seemfa>, <seemfa marker="#error_marker/1">error_marker/1</seemfa>, <seemfa marker="#is_form/1">is_form/1</seemfa>, <seemfa marker="#warning_marker_info/1">warning_marker_info/1</seemfa>.</p>
</desc></func>
<func>
<name since="">warning_marker_info(Node::<seeerl marker="#type-syntaxTree">syntaxTree()</seeerl>) -&gt; term()</name>
<fsummary>Returns the ErrorInfo structure of a warning_marker node.</fsummary>

<desc><marker id="warning_marker_info-1"/>

<p>Returns the ErrorInfo structure of a <c>warning_marker</c> node.
 </p>
<p><em>See also:</em> <seemfa marker="#warning_marker/1">warning_marker/1</seemfa>.</p>
</desc></func></funcs>

<authors>

<aname>Richard Carlsson</aname>
<email>carlsson.richard@gmail.com</email></authors></erlref>